---
description: Use this rules when integrating Neon (serverless Postgres) with Drizzle ORM
globs: *.ts, *.tsx
alwaysApply: false
---
# Neon and Drizzle Integration Guidelines

## Overview

This guide covers the specific integration patterns, configurations, and optimizations for using **Drizzle ORM** with **Neon** Postgres. Follow these guidelines to ensure efficient, secure, and robust database operations in serverless and traditional environments.

## Dependencies
For Neon with Drizzle ORM integration, include these specific dependencies. The `ws` package is required for persistent WebSocket connections in Node.js environments older than v22.

```bash
npm install drizzle-orm @neondatabase/serverless ws
npm install -D drizzle-kit dotenv @types/ws
```

## Neon Connection String
Always use the Neon connection string format and store it in an environment file (`.env`, `.env.local`).

```text
DATABASE_URL="postgresql://[user]:[password]@[neon_hostname]/[dbname]?sslmode=require&channel_binding=require"
```

## Connection Setup: Choosing the Right Driver Adapter

Neon's serverless driver offers two connection methods: HTTP and WebSocket. Drizzle has a specific adapter for each.

### 1. HTTP Adapter (Recommended for Serverless/Edge)
This method is ideal for short-lived, stateless environments like Vercel Edge Functions or AWS Lambda. It uses `fetch` for each query, resulting in very low latency for single operations.

- Use the `neon` client from `@neondatabase/serverless`.
- Use the `drizzle` adapter from `drizzle-orm/neon-http`.

```typescript
// src/db.ts
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import { config } from "dotenv";

config({ path: ".env" });

if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL is not defined');
}

const sql = neon(process.env.DATABASE_URL);
export const db = drizzle(sql);
```

### 2. WebSocket Adapter (for `node-postgres` compatibility)
This method is suitable for long-running applications (e.g., a standard Node.js server) or when you need support for interactive transactions. It maintains a persistent WebSocket connection.

- Use the `Pool` client from `@neondatabase/serverless`.
- Use the `drizzle` adapter from `drizzle-orm/neon-serverless`.
- Configure the WebSocket constructor for Node.js environments older than v22.

```typescript
// src/db.ts
import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import { config } from "dotenv";
import ws from 'ws';

config({ path: ".env" });

if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL is not defined');
}

// Required for Node.js < v22
neonConfig.webSocketConstructor = ws;

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool);
```

## Drizzle Config for Neon
Configure `drizzle.config.ts` to manage your schema and migrations. Neon is fully Postgres-compatible, so the dialect is `postgresql`.

```typescript
// drizzle.config.ts
import { config } from 'dotenv';
import { defineConfig } from "drizzle-kit";

config({ path: '.env.local' }); // Use .env.local for local dev

export default defineConfig({
  schema: "./src/schema.ts",
  out: "./drizzle", // Or your preferred migrations folder
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  }
});
```

## Migrations with Drizzle Kit
`drizzle-kit` is used to generate and apply schema changes to your Neon database.

### 1. Generate Migrations
After changing your schema in `src/schema.ts`, generate a new migration file.

```bash
npx drizzle-kit generate
```

### 2. Apply Migrations
Apply migrations via the command line or programmatically.

**Command Line:**
```bash
npx drizzle-kit migrate
```

**Programmatic (for Vercel deploy hooks):**
```typescript
import { migrate } from 'drizzle-orm/neon-http/migrator';
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);
await migrate(db, { migrationsFolder: './drizzle' });
```

## Schema Considerations for Neon

### Standard Postgres Schema
Define your schema using Postgres-specific types from `drizzle-orm/pg-core`.

```typescript
// src/schema.ts
import { pgTable, serial, text, integer, timestamp } from 'drizzle-orm/pg-core';

export const usersTable = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  role: text('role').default('user').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

// Export types for type safety
export type User = typeof usersTable.$inferSelect;
export type NewUser = typeof usersTable.$inferInsert;
```

## Neon-Specific Query Optimizations

### Efficient Queries for Serverless
Optimize for Neon's serverless environment:
- Keep connections short-lived
- Use prepared statements for repeated queries (when driver supports)
- Batch operations when possible

```typescript
// Example of optimized query for Neon
export async function batchInsertUsers(users: NewUser[]) {
  return db.insert(usersTable).values(users).returning();
}
```

## Working with Neon Branches
Manage connections to dev/test/prod branches using environment variables:

- `DEV_DATABASE_URL` — local development
- `TEST_DATABASE_URL` — tests
- `DATABASE_URL` — production; preview deploys use branch-specific URL

## Neon-Specific Error Handling
Handle Neon connection pool timeout and query_wait_timeout. Use `isDbTimeoutError` and `getDbTimeoutCode` from afena-database for metering and alerting.
