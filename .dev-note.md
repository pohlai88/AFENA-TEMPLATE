# Afena Nexus — Developer Notes

> Internal reference for the Neon + Drizzle + Auth architecture.
> Last updated: 2026-02-11

---

## Architecture Overview

```
apps/web (Next.js 16)
├── Server Components / API Routes ──► packages/database (Drizzle + Neon HTTP)
├── Client Components ───────────────► @neondatabase/neon-js (Data API + Auth)
├── Middleware ───────────────────────► @neondatabase/auth (session validation)
└── Auth API Handler ────────────────► app/api/auth/[...path]/route.ts

packages/database
├── src/db.ts ───────────────────────► Neon Serverless HTTP driver → Drizzle ORM
├── src/schema.ts ───────────────────► Centralized schema (single source of truth)
├── drizzle/ ────────────────────────► SQL migration files
└── drizzle.config.ts ───────────────► Drizzle Kit config (direct TCP for DDL)
```

---

## Database Access Patterns

### 1. Server-Side: Drizzle ORM (`packages/database`)

**When:** Server Components, API routes, server actions, cron jobs, scripts.

**Driver:** `@neondatabase/serverless` (HTTP mode) via `drizzle-orm/neon-http`.

**Why HTTP:** Stateless, no connection pool needed, works in serverless/edge. Each query is a single fetch request. Neon's recommended driver for Next.js.

```typescript
import { db, users } from 'afena-database';
import { eq } from 'drizzle-orm';

const user = await db.select().from(users).where(eq(users.id, id));
```

**Connection URLs:**

| Variable | URL Type | Used By |
|----------|----------|---------|
| `DATABASE_URL` | Pooled (PgBouncer) | Runtime queries via Drizzle |
| `DATABASE_URL_MIGRATIONS` | Direct TCP (no pooler) | `drizzle-kit generate/migrate/push` |

**Why two URLs:** PgBouncer (pooled) doesn't support DDL operations, advisory locks, or `CREATE INDEX CONCURRENTLY`. Migrations must use direct TCP.

### 2. Client-Side: Neon Data API (`@neondatabase/neon-js`)

**When:** Browser components that need to read/write data with user context.

**Driver:** REST (PostgREST-compatible). Auth tokens injected automatically.

**Why:** Standard Postgres drivers don't work in browsers. The Data API provides a Supabase-like query builder that respects Row-Level Security (RLS).

```typescript
import neon from '@/lib/neon';

const { data } = await neon.from('todos').select('*');
```

**Important:** Data API queries are gated by RLS policies. Without RLS, all data is accessible. Always add RLS policies before exposing tables to the client.

**Status:** Beta (as of Feb 2026).

---

## Authentication

### Stack

| Layer | Package | Purpose |
|-------|---------|---------|
| **Server SDK** | `@neondatabase/auth/next/server` | Session management, route protection, server-side auth methods |
| **Client SDK** | `@neondatabase/neon-js` | Client-side sign-in/up/out, OAuth, session access |
| **Engine** | Better Auth v1.4.6 (managed by Neon) | Underlying auth framework |

### How It Works

1. **Auth data lives in your Neon database** — stored in the `neon_auth` schema, queryable with SQL, branches with your DB.
2. **Server SDK** (`createNeonAuth()`) handles session cookies, token refresh, and provides `auth.getSession()` for RSC/API routes.
3. **Client SDK** (`neon.auth.*`) provides browser-side auth methods (sign-in, sign-up, OAuth, OTP).
4. **Middleware** validates sessions on every request, redirects unauthenticated users.

### File Layout

```
apps/web/
├── src/lib/auth/
│   ├── server.ts          ← createNeonAuth() instance
│   └── client.ts          ← re-exports neon client for auth
├── src/lib/neon.ts        ← createClient() with auth + data API URLs
├── middleware.ts           ← auth.middleware() + logging middleware
└── app/api/auth/
    └── [...path]/
        └── route.ts       ← auth.handler() catch-all
```

### Environment Variables

```
NEON_AUTH_BASE_URL           ← Neon Auth server URL (from Console)
NEON_AUTH_COOKIE_SECRET      ← 32+ chars for HMAC-SHA256 session signing
NEXT_PUBLIC_NEON_AUTH_URL    ← Public auth URL for client SDK
NEON_DATA_API_URL            ← Data API endpoint for client queries
NEON_JWT_SECRET              ← JWT signing secret
JWKS_URL                     ← JSON Web Key Set URL for token verification
```

### Auth Methods Available

**Server (`auth.*`):**
- `auth.getSession()` — get current session in RSC/API routes
- `auth.handler()` — creates GET/POST route handlers
- `auth.middleware()` — session validation middleware
- `auth.signIn.email()`, `auth.signUp.email()`, `auth.signOut()`
- `auth.admin.listUsers()`, `auth.admin.banUser()`, `auth.admin.setRole()`
- `auth.organization.create()`, `auth.organization.inviteMember()`

**Client (`neon.auth.*`):**
- `neon.auth.signIn.email({ email, password })`
- `neon.auth.signUp.email({ email, password, name })`
- `neon.auth.signIn.social({ provider: 'github' })`
- `neon.auth.signOut()`
- `neon.auth.getSession()`
- `neon.auth.emailOtp.sendVerificationOtp()`

---

## Migrations

### Workflow

```bash
# 1. Edit schema in packages/database/src/schema.ts
# 2. Generate migration SQL
pnpm --filter afena-database db:generate

# 3. Review generated SQL in packages/database/drizzle/
# 4. Apply to Neon
pnpm --filter afena-database db:migrate

# Dev shortcut: push schema directly (no migration file)
pnpm --filter afena-database db:push

# Visual schema browser
pnpm --filter afena-database db:studio
```

### Rules

- **Always generate + review** before applying. Never blindly push to production.
- **Migration URL** uses direct TCP (no pooler) — set in `packages/database/.env`.
- **Schema is the single source of truth** — all tables defined in `packages/database/src/schema.ts`.
- **Don't touch `neon_auth` schema** — managed by Neon Auth. Your app tables go in the `public` schema.

---

## Neon Project Details

| Field | Value |
|-------|-------|
| **Project** | `nexuscanon-axis` |
| **Project ID** | `dark-band-87285012` |
| **Org ID** | `org-fragrant-lake-90358173` |
| **Region** | `aws-ap-southeast-1` |
| **Postgres** | v17 |
| **Plan** | `launch_v3` (up to 1M MAU) |
| **Branch** | `br-icy-darkness-a1eom4rq` |

---

## Packages Summary

| Package | Purpose | Consumes |
|---------|---------|----------|
| `afena-database` | Schema, Drizzle client, migrations | `@neondatabase/serverless`, `drizzle-orm` |
| `afena-logger` | Structured logging (pino) + middleware | `pino` |
| `afena-ui` | Shared UI components + design engine | `react`, `tailwindcss` |
| `@afena/cli` | Monorepo tooling (discover, register) | `commander`, `cosmiconfig` |
| `web` (app) | Next.js 16 application | All packages above + Neon Auth/Data API |

---

## Key Decisions

1. **Neon Serverless HTTP** over WebSocket/pg — stateless, no pool management, works everywhere.
2. **Drizzle ORM** over Prisma — lighter, SQL-first, better serverless support, schema-as-code.
3. **Neon Auth** over self-hosted Better Auth — zero infra, branches with DB, managed OAuth.
4. **Separate `packages/database`** — centralized schema consumed by all apps, single migration path.
5. **Two DB access patterns** — Drizzle for server (full access), Data API for client (RLS-gated).
6. **Logger middleware decoupled from `next`** — uses generic `MiddlewareRequest` interface to avoid type conflicts from duplicate `next` package instances.

---

## Beta / Known Limitations

- **Neon Data API** — Beta. PostgREST-compatible REST interface.
- **Neon Auth** — Beta. Built on Better Auth v1.4.6. Check [roadmap](https://neon.com/docs/auth/roadmap).
- **AWS regions only** — Neon Auth doesn't support Azure yet.
- **No IP Allow / Private Networking** with Neon Auth.
- **`@better-auth/passkey`** has unmet peer deps (1.4.18 vs 1.4.6) — cosmetic warning, doesn't affect functionality.
