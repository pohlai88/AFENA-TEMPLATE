# Afena Nexus — Developer Notes

> Internal reference for the Neon + Drizzle + Auth architecture.
> Last updated: 2026-02-12 (Session 4 — CRUD-SAP Phases 1–3 complete)

---

## Architecture Overview

```
apps/web (Next.js 16)
├── Server Components / API Routes ──► packages/database (Drizzle + Neon HTTP)
├── Client Components ───────────────► @neondatabase/neon-js (Data API + Auth)
├── Middleware ───────────────────────► @neondatabase/auth (session validation)
└── Auth API Handler ────────────────► app/api/auth/[...path]/route.ts

packages/database
├── src/db.ts ───────────────────────► Neon Serverless HTTP driver → Drizzle ORM
├── src/schema.ts ───────────────────► Centralized schema (single source of truth)
├── drizzle/ ────────────────────────► SQL migration files
└── drizzle.config.ts ───────────────► Drizzle Kit config (direct TCP for DDL)
```

---

## Database Access Patterns

### 1. Server-Side: Drizzle ORM (`packages/database`)

**When:** Server Components, API routes, server actions, cron jobs, scripts.

**Driver:** `@neondatabase/serverless` (HTTP mode) via `drizzle-orm/neon-http`.

**Why HTTP:** Stateless, no connection pool needed, works in serverless/edge. Each query is a single fetch request. Neon's recommended driver for Next.js.

```typescript
import { db, users, r2Files } from 'afena-database';
import { eq } from 'drizzle-orm';

// Simple query
const user = await db.select().from(users).where(eq(users.id, id));

// Relational query (uses Drizzle relations)
const userWithFiles = await db.query.users.findFirst({
  where: eq(users.userId, authUserId),
  with: { r2Files: true },
});
```

**Connection URLs:**

| Variable                  | URL Type               | Used By                             |
| ------------------------- | ---------------------- | ----------------------------------- |
| `DATABASE_URL`            | Pooled (PgBouncer)     | Runtime queries via Drizzle         |
| `DATABASE_URL_MIGRATIONS` | Direct TCP (no pooler) | `drizzle-kit generate/migrate/push` |

**Why two URLs:** PgBouncer (pooled) doesn't support DDL operations, advisory locks, or `CREATE INDEX CONCURRENTLY`. Migrations must use direct TCP.

### 2. Client-Side: Neon Data API (`@neondatabase/neon-js`)

**When:** Browser components that need to read/write data with user context.

**Driver:** REST (PostgREST-compatible). Auth tokens injected automatically.

**Why:** Standard Postgres drivers don't work in browsers. The Data API provides a Supabase-like query builder that respects Row-Level Security (RLS).

```typescript
import neon from '@/lib/neon';

const { data } = await neon.from('todos').select('*');
```

**Important:** Data API queries are gated by RLS policies. Without RLS, all data is accessible. Always add RLS policies before exposing tables to the client.

**Status:** Beta (as of Feb 2026).

---

## Authentication

### Stack

| Layer          | Package                              | Purpose                                                        |
| -------------- | ------------------------------------ | -------------------------------------------------------------- |
| **Server SDK** | `@neondatabase/auth/next/server`     | Session management, route protection, server-side auth methods |
| **Client SDK** | `@neondatabase/neon-js`              | Client-side sign-in/up/out, OAuth, session access              |
| **Engine**     | Better Auth v1.4.6 (managed by Neon) | Underlying auth framework                                      |

### How It Works

1. **Auth data lives in your Neon database** — stored in the `neon_auth` schema, queryable with SQL, branches with your DB.
2. **Server SDK** (`createNeonAuth()`) handles session cookies, token refresh, and provides `auth.getSession()` for RSC/API routes.
3. **Client SDK** (`neon.auth.*`) provides browser-side auth methods (sign-in, sign-up, OAuth, OTP).
4. **Middleware** validates sessions on every request, redirects unauthenticated users.

### File Layout

```
apps/web/
├── src/lib/auth/
│   ├── server.ts          ← createNeonAuth() instance
│   └── client.ts          ← re-exports neon client for auth
├── src/lib/neon.ts        ← createClient() with auth + data API URLs
├── proxy.ts               ← auth.middleware() + logging (Next.js 16 proxy convention)
└── app/api/auth/
    └── [...path]/
        └── route.ts       ← auth.handler() catch-all
```

### Environment Variables

```
NEON_AUTH_BASE_URL           ← Neon Auth server URL (from Console)
NEON_AUTH_COOKIE_SECRET      ← 32+ chars for HMAC-SHA256 session signing
NEXT_PUBLIC_NEON_AUTH_URL    ← Public auth URL for client SDK
NEON_DATA_API_URL            ← Data API endpoint for client queries
NEON_JWT_SECRET              ← JWT signing secret
JWKS_URL                     ← JSON Web Key Set URL for token verification
```

### Auth Methods Available

**Server (`auth.*`):**

- `auth.getSession()` — get current session in RSC/API routes
- `auth.handler()` — creates GET/POST route handlers
- `auth.middleware()` — session validation middleware
- `auth.signIn.email()`, `auth.signUp.email()`, `auth.signOut()`
- `auth.admin.listUsers()`, `auth.admin.banUser()`, `auth.admin.setRole()`
- `auth.organization.create()`, `auth.organization.inviteMember()`

**Client (`neon.auth.*`):**

- `neon.auth.signIn.email({ email, password })`
- `neon.auth.signUp.email({ email, password, name })`
- `neon.auth.signIn.social({ provider: 'github' })`
- `neon.auth.signOut()`
- `neon.auth.getSession()`
- `neon.auth.emailOtp.sendVerificationOtp()`

---

## Migrations

### Workflow

```bash
# 1. Edit schema in packages/database/src/schema.ts
# 2. Generate migration SQL
pnpm --filter afena-database db:generate

# 3. Review generated SQL in packages/database/drizzle/
# 4. Apply to Neon
pnpm --filter afena-database db:migrate

# Dev shortcut: push schema directly (no migration file)
pnpm --filter afena-database db:push

# Visual schema browser
pnpm --filter afena-database db:studio
```

### Applied Migrations

| Migration                        | Description                                                             |
| -------------------------------- | ----------------------------------------------------------------------- |
| `0000_first_stranger`            | Create `users` table                                                    |
| `0001_true_night_nurse`          | Enable RLS + policies on `users`                                        |
| `0002_mature_carmella_unuscione` | Create `r2_files` table with RLS                                        |
| `0003_condemned_hellfire_club`   | Add `users.user_id` UNIQUE, indexes on `user_id`, FK `r2_files → users` |
| `0004_cultured_ogun`             | Change FK to `ON DELETE CASCADE`                                        |

### Rules

- **Always generate + review** before applying. Never blindly push to production.
- **Migration URL** uses direct TCP (no pooler) — set in `packages/database/.env`.
- **Schema is the single source of truth** — all tables defined in `packages/database/src/schema.ts`.
- **Don't touch `neon_auth` schema** — managed by Neon Auth. Your app tables go in the `public` schema.
- **Reorder migration SQL if needed** — Drizzle may generate FK before the referenced UNIQUE constraint. Always verify order.

---

## Neon Project Details

| Field          | Value                        |
| -------------- | ---------------------------- |
| **Project**    | `nexuscanon-axis`            |
| **Project ID** | `dark-band-87285012`         |
| **Org ID**     | `org-fragrant-lake-90358173` |
| **Region**     | `aws-ap-southeast-1`         |
| **Postgres**   | v17.7                        |
| **Plan**       | `launch_v3` (up to 1M MAU)   |
| **Branch**     | `br-icy-darkness-a1eom4rq`   |

---

### Database Settings (applied via `ALTER DATABASE`)

| Setting                               | Value  | Why                                                   |
| ------------------------------------- | ------ | ----------------------------------------------------- |
| `statement_timeout`                   | `30s`  | Prevents runaway queries from consuming compute       |
| `random_page_cost`                    | `1.1`  | Optimized for Neon SSD storage (default 4 is for HDD) |
| `idle_in_transaction_session_timeout` | `300s` | Already set by Neon (5 min)                           |
| `lock_timeout`                        | `10s`  | Prevents indefinite lock waits                        |

> **Note:** `log_min_duration_statement`, `log_lock_waits`, `deadlock_timeout` are Neon superuser-only and cannot be set.

### Role Grants (Data API / RLS)

`authenticated` role has CRUD privileges on all public tables. Default privileges ensure future tables auto-grant:

```sql
-- Existing tables
GRANT SELECT, INSERT, UPDATE, DELETE ON public.users TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.r2_files TO authenticated;

-- Future tables (prevents relapse)
ALTER DEFAULT PRIVILEGES FOR ROLE neondb_owner IN SCHEMA public
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE neondb_owner IN SCHEMA public
  GRANT USAGE, SELECT ON SEQUENCES TO authenticated;
```

> **Canon invariant:** Postgres requires BOTH table privileges (GRANT) AND RLS policies for a role to access rows. Policies without grants = dead policies.

### Database Triggers

| Trigger                | Table   | Function           | Purpose                                |
| ---------------------- | ------- | ------------------ | -------------------------------------- |
| `users_set_updated_at` | `users` | `set_updated_at()` | Auto-update `updated_at` on row change |

### Schema Relationships

```
users (1) ──── (∞) r2_files
  │                    │
  ├─ id (PK, uuid)     ├─ id (PK, uuid)
  ├─ user_id (UNIQUE)◄─┤─ user_id (FK → users.user_id, ON DELETE CASCADE)
  ├─ email (UNIQUE)    ├─ object_key (UNIQUE)
  └─ ...               └─ ...

Indexes: users_user_id_idx, r2_files_user_id_idx (for RLS performance)
RLS: CRUD policies on both tables via authenticated role + auth.user_id()
Trigger: users_set_updated_at (BEFORE UPDATE → set_updated_at())
```

---

## Packages Summary

| Package          | Purpose                                | Consumes                                               |
| ---------------- | -------------------------------------- | ------------------------------------------------------ |
| `afena-database` | Schema, Drizzle client, migrations     | `@neondatabase/serverless`, `drizzle-orm`              |
| `afena-logger`   | Structured logging (pino) + middleware | `pino`                                                 |
| `afena-ui`       | Shared UI components + design engine   | `react`, `tailwindcss`                                 |
| `@afena/cli`     | Monorepo tooling (discover, register)  | `commander`, `cosmiconfig`                             |
| `web` (app)      | Next.js 16 application                 | All packages above + Neon Auth/Data API + AWS SDK (R2) |

---

## Key Decisions

1. **Neon Serverless HTTP** over WebSocket/pg — stateless, no pool management, works everywhere.
2. **Drizzle ORM** over Prisma — lighter, SQL-first, better serverless support, schema-as-code.
3. **Neon Auth** over self-hosted Better Auth — zero infra, branches with DB, managed OAuth.
4. **Separate `packages/database`** — centralized schema consumed by all apps, single migration path.
5. **Two DB access patterns** — Drizzle for server (full access), Data API for client (RLS-gated).
6. **Logger middleware decoupled from `next`** — uses generic `MiddlewareRequest` interface to avoid type conflicts from duplicate `next` package instances.

---

## File Storage (Neon + Cloudflare R2)

### Architecture

Files are stored in Cloudflare R2 (S3-compatible, zero egress fees). Metadata is stored in Neon (`r2_files` table with RLS). Upload flow uses presigned URLs — files go directly from browser to R2, never touching the server.

### File Layout

```
apps/web/
├── src/lib/r2.ts                          ← S3Client for R2
├── app/api/storage/
│   ├── presign/route.ts                   ← Generate presigned upload URL
│   └── metadata/route.ts                  ← Save/list file metadata (POST/GET)
packages/database/
└── src/schema.ts                          ← r2_files table with RLS
```

### API Endpoints

| Endpoint                | Method | Purpose                          |
| ----------------------- | ------ | -------------------------------- |
| `/api/storage/presign`  | POST   | Generate presigned R2 upload URL |
| `/api/storage/metadata` | POST   | Save file metadata after upload  |
| `/api/storage/metadata` | GET    | List user's files (RLS-gated)    |

### Environment Variables

```
R2_ACCOUNT_ID              ← Cloudflare account ID
R2_ACCESS_KEY_ID           ← R2 API token access key
R2_SECRET_ACCESS_KEY       ← R2 API token secret
R2_BUCKET_NAME             ← Bucket name (default: axis-attachments)
R2_PUBLIC_BASE_URL         ← Optional: public bucket URL for direct read links
```

### Upload Validation (presign route)

- **Content type whitelist:** images (jpeg/png/gif/webp/svg), PDF, text, CSV, JSON, Word, Excel
- **Max file size:** 50 MB (validated server-side + enforced via `ContentLength` in presigned URL)
- **Presign expiry:** 300s (5 min)

### CORS Policy (`packages/database/scripts/r2-cors.json`)

Restricts browser uploads to allowed origins only.

```json
[
  {
    "AllowedOrigins": [
      "http://localhost:3000",
      "https://nexuscanon.com",
      "https://*.nexuscanon.com"
    ],
    "AllowedMethods": ["PUT"],
    "AllowedHeaders": ["Content-Type"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 3600
  }
]
```

**Status:** Policy file created. Apply with:

```bash
npx wrangler r2 bucket cors set axis-attachments --file packages/database/scripts/r2-cors.json
```

### TODO: UI

File upload UI components are pending the UI kit. The API routes and backend are ready.

---

## Tooling

| Tool                     | Purpose                                    |
| ------------------------ | ------------------------------------------ |
| `psql` (v18.1 via scoop) | Direct SQL access to Neon                  |
| `neonctl`                | Neon CLI (project/branch management)       |
| Neon MCP                 | AI-assisted DB operations via Cascade      |
| `wrangler`               | Cloudflare R2 management (CORS, lifecycle) |

---

## Remaining Configuration

- [x] **Apply R2 CORS policy** — run `npx wrangler r2 bucket cors set axis-attachments --file packages/database/scripts/r2-cors.json`
- [x] **R2 lifecycle rule** — abort incomplete multipart uploads after 1 day (via Cloudflare dashboard or wrangler)
- [ ] **File upload UI** — components pending UI kit integration
- [x] **Remove `R2_ENDPOINT`** from `.env` — done
- [x] **OAuth providers** — GitHub/Google OAuth configured in Neon Auth console but `GITHUB_ID`/`GITHUB_SECRET` in `.env` need to be wired to auth config if using server-side OAuth

---

## Beta / Known Limitations

- **Neon Data API** — Beta. PostgREST-compatible REST interface.
- **Neon Auth** — Beta. Built on Better Auth v1.4.6. Check [roadmap](https://neon.com/docs/auth/roadmap).
- **AWS regions only** — Neon Auth doesn't support Azure yet.
- **No IP Allow / Private Networking** with Neon Auth.
- **`@better-auth/passkey`** has unmet peer deps (1.4.18 vs 1.4.6) — cosmetic warning, doesn't affect functionality.

---

## CRUD-SAP — Kernel + UI + Search (Phases 1–3)

> Completed: 2026-02-12

### Architecture

```
packages/canon (afena-canon)     ← Types, Zod schemas, ErrorCode, ActionFamily, ApiResponse
packages/crud (afena-crud)       ← Kernel: mutate(), readEntity(), listEntities()
packages/search (afena-search)   ← FTS helpers, cross-entity registry, contacts adapter
packages/database                ← Schema: contacts, audit_logs, entity_versions, mutation_batches

apps/web
├── app/actions/contacts.ts      ← Server actions (create/update/delete/restore/read/list/audit/versions)
├── app/api/search/route.ts      ← GET /api/search?q=&limit= (delegates to afena-search)
├── app/command-palette.tsx       ← ⌘K/Ctrl+K command palette (react-query + cmdk)
├── app/query-provider.tsx        ← @tanstack/react-query QueryClientProvider
└── app/(app)/org/[slug]/contacts/
    ├── page.tsx                  ← List view (DataTable)
    ├── new/page.tsx              ← Create form
    ├── [id]/page.tsx             ← Detail view (metadata, links to versions + audit)
    ├── [id]/edit/page.tsx        ← Edit form
    ├── [id]/versions/page.tsx    ← Version history with revert
    ├── [id]/audit/page.tsx       ← Audit trail timeline
    ├── trash/page.tsx            ← Soft-deleted records with restore
    └── _components/
        ├── contact-form.tsx      ← Shared create/edit form (client)
        ├── delete-contact-button.tsx
        ├── restore-contact-button.tsx
        └── revert-button.tsx
```

### Kernel Invariants (K-01 through K-15)

| ID   | Rule                                                 |
| ---- | ---------------------------------------------------- |
| K-01 | `mutate()` is the only way to write domain data      |
| K-02 | Single DB transaction per mutation                   |
| K-03 | Always writes `audit_logs` + `entity_versions`       |
| K-04 | `expectedVersion` required on update/delete/restore  |
| K-05 | Exports ONLY `mutate`, `readEntity`, `listEntities`  |
| K-06 | Namespaced actions: `{entity}.{verb}`                |
| K-07 | Deterministic receipt status: ok / rejected / error  |
| K-08 | `updated_at` set by DB trigger only                  |
| K-09 | `entityRef.id` optional on create                    |
| K-10 | `idempotencyKey` for `*.create` only                 |
| K-11 | Allowlist input + kernel backstop strips system cols |
| K-12 | Receipt nullable fields on rejected/error            |
| K-13 | Diff normalizes snapshots first, no post-filter      |
| K-14 | `audit_logs` RLS actor check                         |
| K-15 | `actionType` namespace must match `entityRef.type`   |

### Database Tables (Phase 1)

| Table              | Purpose                                                                      |
| ------------------ | ---------------------------------------------------------------------------- |
| `contacts`         | First domain entity (name, email, phone, company, notes + baseEntityColumns) |
| `audit_logs`       | Append-only mutation audit trail (before/after/diff JSONB)                   |
| `entity_versions`  | Snapshot-first version history (version, parentVersion, snapshot, diff)      |
| `mutation_batches` | Batch grouping for multi-mutation operations                                 |

### ESLint INVARIANT-01

`no-restricted-syntax` in `base.js` blocks `db.insert()`, `db.update()`, `db.delete()` globally. `packages/crud` and `packages/search` override to allow kernel/read queries.

### Search (Phase 3)

- **FTS helpers:** `toTsQuery()`, `ftsWhere()`, `ftsRank()` (tsvector/tsquery ready)
- **Fallback:** `ilikeFallback()` + contacts adapter uses ILIKE for now
- **Registry:** `registerSearchableEntity()`, `crossEntitySearch()` for multi-entity fan-out
- **Command palette:** ⌘K with live search via `@tanstack/react-query`, navigation, quick actions

### Dependencies Added

| Package                 | Version   | Where                   |
| ----------------------- | --------- | ----------------------- |
| `fast-json-patch`       | ~3.1.1    | catalog → packages/crud |
| `vitest`                | ~3.2.3    | catalog → packages/crud |
| `@tanstack/react-query` | ~5.80.7   | catalog → apps/web      |
| `afena-canon`           | workspace | apps/web                |
| `afena-crud`            | workspace | apps/web                |
| `afena-search`          | workspace | apps/web                |

### Smoke Tests

15/15 passing in `packages/crud/src/__tests__/kernel.smoke.test.ts` — covers K-04, K-05, K-06, K-09, K-11, K-13, K-15, error code taxonomy.

### Known Gotchas

- **Zod v4:** `z.record()` requires 2 args. UUID validation is strict RFC 4122 (variant bits must be correct).
- **`exactOptionalPropertyTypes`:** Optional props in interfaces need `| undefined` suffix.
- **`auth.getSession()`:** Returns `{ data: session }` — must destructure.
- **`packages/ui` `@/` imports:** Resolve via web tsconfig paths `"@/*": ["./*", "../../packages/ui/src/*"]`. `dialog.tsx` and `command.tsx` were fixed to relative imports for cross-package safety.

---

## Workflow Engine (Phase 4)

> Completed: 2026-02-12

### Architecture

```
packages/workflow (afena-workflow)
├── src/types.ts        ← WorkflowRule, RuleContext, ConditionFn, ActionFn, RuleEvaluationResult
├── src/registry.ts     ← registerRule(), unregisterRule(), getRegisteredRules(), clearRules()
├── src/engine.ts       ← evaluateRules(timing, spec, entity, ctx) — core evaluation loop
├── src/conditions.ts   ← Built-in: always, never, fieldEquals, fieldChanged, actorHasRole, allOf, anyOf
└── src/index.ts        ← Barrel export
```

### How It Works

1. **Rules are registered at app startup** via `registerRule()` — sorted by priority (lower = first).
2. **`mutate()` calls `evaluateRules('before', ...)` after policy enforcement** — before-rules can:
   - **Block** the mutation (return `{ ok: false, message }`)
   - **Enrich** the input (return `{ ok: true, enrichedInput: {...} }`)
   - **Throw** → mutation is blocked (fail-safe)
3. **`mutate()` calls `evaluateRules('after', ...)` after transaction commit** — fire-and-forget:
   - Side effects only (notifications, cascading mutations, etc.)
   - Errors are swallowed — never affect the mutation response

### Rule Definition

```typescript
const rule: WorkflowRule = {
  id: 'require-email-on-create',
  name: 'Require email on contact create',
  timing: 'before',
  entityTypes: ['contacts'], // empty = all entities
  verbs: ['create'], // empty = all verbs
  priority: 50, // lower = runs first (default 100)
  enabled: true,
  condition: fieldEquals('email', undefined), // or allOf(), anyOf(), custom fn
  action: () => ({ ok: false, message: 'Email is required' }),
};
registerRule(rule);
```

### Built-in Conditions

| Helper                      | Description                        |
| --------------------------- | ---------------------------------- |
| `always`                    | Always matches                     |
| `never`                     | Never matches                      |
| `fieldEquals(field, value)` | Input field equals value           |
| `fieldChanged(field)`       | Field differs from entity snapshot |
| `actorHasRole(role)`        | Actor has specific role            |
| `allOf(...conds)`           | AND — all must match               |
| `anyOf(...conds)`           | OR — at least one must match       |

### Integration Points in `mutate()`

```
mutate()
  1. Validate MutationSpec (Zod)
  2. K-15 namespace check
  3. Strip system columns (K-11)
  4. Enforce expectedVersion (K-04)
  5. Idempotency check (K-10)
  6. Policy enforcement
→ 7. evaluateRules('before', ...) ← CAN BLOCK / ENRICH
  8. Resolve handler
  9. Transaction: handler + audit + version
→ 10. evaluateRules('after', ...) ← FIRE-AND-FORGET
  11. Return receipt
```

### Smoke Tests

23/23 passing in `packages/workflow/src/__tests__/engine.smoke.test.ts`:

- Rule registration + priority sorting
- Before-rules: proceed, block, throw (fail-safe), skip on condition miss, enrich input
- After-rules: execute without blocking, swallow errors
- Entity/verb filtering, disabled rule skipping
- All built-in conditions: fieldEquals, fieldChanged, actorHasRole, allOf, anyOf

---

## Advisory Engine — Phase 5 (Deterministic, Math-First)

> Completed: 2026-02-12

### Invariants

- **INVARIANT-P01**: Advisory engine ONLY writes to `advisories` + `advisory_evidence`. Never domain tables.
- **INVARIANT-P02**: `advisory_evidence` is append-only. No UPDATE, no DELETE.
- **INVARIANT-P03**: Open/ack advisories deduplicated by `(org_id, fingerprint)`.

### Architecture

```
packages/advisory (afena-advisory)
├── src/types.ts              ← Advisory, Evidence, Detector/Forecaster/Scoring result types
├── src/fingerprint.ts        ← Deterministic SHA-256 hex (stable-stringify, 64-char output)
├── src/detectors/
│   ├── ewma.ts               ← Exponentially Weighted Moving Average (drift/spike detection)
│   ├── cusum.ts              ← Cumulative Sum (change-point detection)
│   └── mad.ts                ← Median Absolute Deviation (robust outlier detection)
├── src/forecasters/
│   ├── ses.ts                ← Simple Exponential Smoothing
│   ├── holt.ts               ← Holt's linear trend
│   └── holt-winters.ts       ← Holt-Winters seasonal (additive + multiplicative, P10/P50/P90)
├── src/scoring/
│   ├── z-score.ts            ← Standard + robust (MAD-based) z-scores
│   └── confidence.ts         ← Quantile bands (P10/P50/P90), prediction intervals
├── src/rules/
│   └── rule-detector.ts      ← Business invariant checks (credit limits, aging, custom)
├── src/evidence.ts           ← Evidence builder (SHA-256 hash for reproducibility)
├── src/explain/
│   ├── templates.ts          ← Pure string templates per method (versioned)
│   ├── render.ts             ← Template + params + score → plain English
│   └── version.ts            ← EXPLAIN_VERSION constants (v1)
├── src/writer.ts             ← Advisory writer (fingerprint dedupe, append-only evidence)
└── src/index.ts              ← Barrel export
```

### Database Tables

**`advisories`** — DB-hardened with CHECK constraints:

- `type` regex: `^(anomaly|forecast|rule)\.[a-z0-9_]+\.[a-z0-9_]+$`
- `severity` IN ('info','warn','critical')
- `status` IN ('open','ack','dismissed')
- `method` IN ('EWMA','CUSUM','MAD','SES','HOLT','HOLT_WINTERS','RULE')
- `fingerprint` CHECK length = 64 (SHA-256 hex)
- `score` DOUBLE PRECISION (not NUMERIC)
- `created_by` DEFAULT COALESCE(auth.user_id(), 'system')
- `window_start`/`window_end` for reproducibility
- `explain_version` for drift-proof explanations
- Unique partial index: `(org_id, fingerprint) WHERE status IN ('open','ack')`

**`advisory_evidence`** — append-only:

- Own `org_id` for direct RLS (no join inheritance)
- SELECT + INSERT only for authenticated role
- Hash canonicalization: sorted keys, no whitespace, arrays preserve order

### Smoke Tests

25/25 passing in `packages/advisory/src/__tests__/advisory.smoke.test.ts`:

- EWMA: spike detection + normal data
- CUSUM: change-point detection + stable series
- MAD: outlier identification + uniform data
- SES/Holt/Holt-Winters: forecast correctness + P10/P50/P90 bands
- Z-score: standard + robust (MAD-based)
- Confidence bands + prediction intervals
- Fingerprint: deterministic, differs on input change, stable stringify
- Evidence: reproducible hash, hash verification
- Explanation: template rendering, version handling, unknown version
- Rule detector: credit limit + aging threshold triggers

### Dependencies

- `afena-advisory` depends on `afena-canon`, `afena-database`, `drizzle-orm`
- Root tsconfig.json references updated

---

## Multi-Tenancy — Phase 1 Deferred Items

Phase 0 (auth helpers, Drizzle policies, schema gate, PRD invariants) is complete and deployed. The items below are deferred from Phase 1.

### Org Switcher Component

- **File:** `apps/web/src/components/org-switcher.tsx` (NEW)
- **Deps:** shadcn `dropdown-menu` (already installed)
- Lists user's orgs via Neon Auth `neon_auth.organization` + `neon_auth.member`
- Calls `organization.setActive(orgId)` → updates JWT `activeOrganizationId`
- Redirects to `/org/[slug]/dashboard` after switch

### Org Context Provider

- **File:** `apps/web/src/providers/org-context.tsx` (NEW)
- React context holding current org slug, org ID, user's role
- Populated from URL param `[slug]` + server-side org lookup

### Personal Org Auto-Creation

- **File:** `apps/web/src/lib/auth/server.ts` (MODIFY)
- On first sign-up, auto-create personal org named "{name}'s Workspace"
- **Blocker:** Verify if Neon Auth SDK supports `databaseHooks.session.create.before` or if this needs a DB trigger on `neon_auth.user` INSERT

### Domain Entity Tables with org_id

- **Blocked by:** No domain entities exist yet beyond `users` and `r2_files` (both exempt)
- **When:** First real domain entity (work orders, projects) is created
- **Template:** `tenantPolicy()` + `auth.require_org_id()` DEFAULT + composite indexes
- **Reference:** Plan §4.9 entity template

### Composite Indexes + RLS ENABLE/FORCE

- Tied to domain entity creation above — applied per-table in migration SQL
- Pattern: `ALTER TABLE ... ENABLE ROW LEVEL SECURITY; ALTER TABLE ... FORCE ROW LEVEL SECURITY;`

### Vitest Setup

- Needed for `packages/database/src/__tests__/jwt-org-claim.test.ts`
- Action: `pnpm add -Dw vitest` + create `vitest.config.ts`
