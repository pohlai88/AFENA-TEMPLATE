# Afena Nexus — Developer Notes

> Internal reference for the Neon + Drizzle + Auth architecture.
> Last updated: 2026-02-12 (CRUD-SAP Phases 1–5 complete)

---

## Architecture Overview

```
apps/web (Next.js 16)
├── Server Components / API Routes ──► packages/database (Drizzle + Neon HTTP)
├── Client Components ───────────────► @neondatabase/neon-js (Data API + Auth)
├── Middleware ───────────────────────► @neondatabase/auth (session validation)
└── Auth API Handler ────────────────► app/api/auth/[...path]/route.ts

packages/database
├── src/db.ts ───────────────────────► Neon Serverless HTTP driver → Drizzle ORM
├── src/schema.ts ───────────────────► Centralized schema (single source of truth)
├── drizzle/ ────────────────────────► SQL migration files
└── drizzle.config.ts ───────────────► Drizzle Kit config (direct TCP for DDL)
```

---

## Database Access Patterns

### 1. Server-Side: Drizzle ORM (`packages/database`)

**When:** Server Components, API routes, server actions, cron jobs, scripts.

**Driver:** `@neondatabase/serverless` (HTTP mode) via `drizzle-orm/neon-http`.

**Why HTTP:** Stateless, no connection pool needed, works in serverless/edge. Each query is a single fetch request. Neon's recommended driver for Next.js.

```typescript
import { db, users, r2Files } from 'afena-database';
import { eq } from 'drizzle-orm';

// Simple query
const user = await db.select().from(users).where(eq(users.id, id));

// Relational query (uses Drizzle relations)
const userWithFiles = await db.query.users.findFirst({
  where: eq(users.userId, authUserId),
  with: { r2Files: true },
});
```

**Connection URLs:**

| Variable                  | URL Type               | Used By                             |
| ------------------------- | ---------------------- | ----------------------------------- |
| `DATABASE_URL`            | Pooled (PgBouncer)     | Runtime queries via Drizzle         |
| `DATABASE_URL_MIGRATIONS` | Direct TCP (no pooler) | `drizzle-kit generate/migrate/push` |

**Why two URLs:** PgBouncer (pooled) doesn't support DDL operations, advisory locks, or `CREATE INDEX CONCURRENTLY`. Migrations must use direct TCP.

### 2. Client-Side: Neon Data API (`@neondatabase/neon-js`)

**When:** Browser components that need to read/write data with user context.

**Driver:** REST (PostgREST-compatible). Auth tokens injected automatically.

**Why:** Standard Postgres drivers don't work in browsers. The Data API provides a Supabase-like query builder that respects Row-Level Security (RLS).

```typescript
import neon from '@/lib/neon';

const { data } = await neon.from('todos').select('*');
```

**Important:** Data API queries are gated by RLS policies. Without RLS, all data is accessible. Always add RLS policies before exposing tables to the client.

**Status:** Beta (as of Feb 2026).

---

## Authentication

### Stack

| Layer          | Package                              | Purpose                                                        |
| -------------- | ------------------------------------ | -------------------------------------------------------------- |
| **Server SDK** | `@neondatabase/auth/next/server`     | Session management, route protection, server-side auth methods |
| **Client SDK** | `@neondatabase/neon-js`              | Client-side sign-in/up/out, OAuth, session access              |
| **Engine**     | Better Auth v1.4.6 (managed by Neon) | Underlying auth framework                                      |

### How It Works

1. **Auth data lives in your Neon database** — stored in the `neon_auth` schema, queryable with SQL, branches with your DB.
2. **Server SDK** (`createNeonAuth()`) handles session cookies, token refresh, and provides `auth.getSession()` for RSC/API routes.
3. **Client SDK** (`neon.auth.*`) provides browser-side auth methods (sign-in, sign-up, OAuth, OTP).
4. **Middleware** validates sessions on every request, redirects unauthenticated users.

### File Layout

```
apps/web/
├── src/lib/auth/
│   ├── server.ts          ← createNeonAuth() instance
│   └── client.ts          ← re-exports neon client for auth
├── src/lib/neon.ts        ← createClient() with auth + data API URLs
├── proxy.ts               ← auth.middleware() + logging (Next.js 16 proxy convention)
└── app/api/auth/
    └── [...path]/
        └── route.ts       ← auth.handler() catch-all
```

### Environment Variables

```
NEON_AUTH_BASE_URL           ← Neon Auth server URL (from Console)
NEON_AUTH_COOKIE_SECRET      ← 32+ chars for HMAC-SHA256 session signing
NEXT_PUBLIC_NEON_AUTH_URL    ← Public auth URL for client SDK
NEON_DATA_API_URL            ← Data API endpoint for client queries
NEON_JWT_SECRET              ← JWT signing secret
JWKS_URL                     ← JSON Web Key Set URL for token verification
```

### Auth Methods Available

**Server (`auth.*`):**

- `auth.getSession()` — get current session in RSC/API routes
- `auth.handler()` — creates GET/POST route handlers
- `auth.middleware()` — session validation middleware
- `auth.signIn.email()`, `auth.signUp.email()`, `auth.signOut()`
- `auth.admin.listUsers()`, `auth.admin.banUser()`, `auth.admin.setRole()`
- `auth.organization.create()`, `auth.organization.inviteMember()`

**Client (`neon.auth.*`):**

- `neon.auth.signIn.email({ email, password })`
- `neon.auth.signUp.email({ email, password, name })`
- `neon.auth.signIn.social({ provider: 'github' })`
- `neon.auth.signOut()`
- `neon.auth.getSession()`
- `neon.auth.emailOtp.sendVerificationOtp()`

---

## Migrations

### Workflow

```bash
# 1. Edit schema in packages/database/src/schema.ts
# 2. Generate migration SQL
pnpm --filter afena-database db:generate

# 3. Review generated SQL in packages/database/drizzle/
# 4. Apply to Neon
pnpm --filter afena-database db:migrate

# Dev shortcut: push schema directly (no migration file)
pnpm --filter afena-database db:push

# Visual schema browser
pnpm --filter afena-database db:studio
```

### Applied Migrations

| Migration                        | Description                                                                                                 |
| -------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| `0000_first_stranger`            | Create `users` table                                                                                        |
| `0001_true_night_nurse`          | Enable RLS + policies on `users`                                                                            |
| `0002_mature_carmella_unuscione` | Create `r2_files` table with RLS                                                                            |
| `0003_condemned_hellfire_club`   | Add `users.user_id` UNIQUE, indexes on `user_id`, FK `r2_files → users`                                     |
| `0004_cultured_ogun`             | Change FK to `ON DELETE CASCADE`                                                                            |
| `0005_mixed_abomination`         | CRUD-SAP Phase 1: contacts, audit_logs, entity_versions, mutation_batches, pgcrypto, set_updated_at trigger |
| `0006_quick_firelord`            | Phase 5: advisories + advisory_evidence tables, CHECK constraints, RLS, INVARIANT-P02 hardening             |

### Rules

- **Always generate + review** before applying. Never blindly push to production.
- **Migration URL** uses direct TCP (no pooler) — set in `packages/database/.env`.
- **Schema is the single source of truth** — all tables defined in `packages/database/src/schema.ts`.
- **Don't touch `neon_auth` schema** — managed by Neon Auth. Your app tables go in the `public` schema.
- **Reorder migration SQL if needed** — Drizzle may generate FK before the referenced UNIQUE constraint. Always verify order.

---

## Neon Project Details

| Field          | Value                        |
| -------------- | ---------------------------- |
| **Project**    | `nexuscanon-axis`            |
| **Project ID** | `dark-band-87285012`         |
| **Org ID**     | `org-fragrant-lake-90358173` |
| **Region**     | `aws-ap-southeast-1`         |
| **Postgres**   | v17.7                        |
| **Plan**       | `launch_v3` (up to 1M MAU)   |
| **Branch**     | `br-icy-darkness-a1eom4rq`   |

---

### Database Settings (applied via `ALTER DATABASE`)

| Setting                               | Value  | Why                                                   |
| ------------------------------------- | ------ | ----------------------------------------------------- |
| `statement_timeout`                   | `30s`  | Prevents runaway queries from consuming compute       |
| `random_page_cost`                    | `1.1`  | Optimized for Neon SSD storage (default 4 is for HDD) |
| `idle_in_transaction_session_timeout` | `300s` | Already set by Neon (5 min)                           |
| `lock_timeout`                        | `10s`  | Prevents indefinite lock waits                        |

> **Note:** `log_min_duration_statement`, `log_lock_waits`, `deadlock_timeout` are Neon superuser-only and cannot be set.

### Role Grants (Data API / RLS)

`authenticated` role has CRUD privileges on all public tables. Default privileges ensure future tables auto-grant:

```sql
-- Existing tables
GRANT SELECT, INSERT, UPDATE, DELETE ON public.users TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.r2_files TO authenticated;

-- Future tables (prevents relapse)
ALTER DEFAULT PRIVILEGES FOR ROLE neondb_owner IN SCHEMA public
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE neondb_owner IN SCHEMA public
  GRANT USAGE, SELECT ON SEQUENCES TO authenticated;
```

> **Canon invariant:** Postgres requires BOTH table privileges (GRANT) AND RLS policies for a role to access rows. Policies without grants = dead policies.

### Database Triggers

| Trigger                | Table   | Function           | Purpose                                |
| ---------------------- | ------- | ------------------ | -------------------------------------- |
| `users_set_updated_at` | `users` | `set_updated_at()` | Auto-update `updated_at` on row change |

### Schema Relationships

```
users (1) ──── (∞) r2_files
  │                    │
  ├─ id (PK, uuid)     ├─ id (PK, uuid)
  ├─ user_id (UNIQUE)◄─┤─ user_id (FK → users.user_id, ON DELETE CASCADE)
  ├─ email (UNIQUE)    ├─ object_key (UNIQUE)
  └─ ...               └─ ...

Indexes: users_user_id_idx, r2_files_user_id_idx (for RLS performance)
RLS: CRUD policies on both tables via authenticated role + auth.user_id()
Trigger: users_set_updated_at (BEFORE UPDATE → set_updated_at())
```

---

## Packages Summary

| Package          | Purpose                                        | Consumes                                               |
| ---------------- | ---------------------------------------------- | ------------------------------------------------------ |
| `afena-database` | Schema, Drizzle client, migrations             | `@neondatabase/serverless`, `drizzle-orm`              |
| `afena-canon`    | Types, Zod schemas, ErrorCode, ActionFamily    | `zod`                                                  |
| `afena-crud`     | Kernel: mutate(), readEntity(), listEntities() | `afena-canon`, `afena-database`, `afena-logger`        |
| `afena-search`   | FTS helpers, cross-entity registry             | `afena-database`, `drizzle-orm`                        |
| `afena-workflow` | Rule engine (before/after mutation hooks)      | `afena-canon`                                          |
| `afena-advisory` | Detectors, forecasters, scoring, rules, writer | `afena-canon`, `afena-database`, `drizzle-orm`         |
| `afena-logger`   | Structured logging (pino) + middleware         | `pino`                                                 |
| `afena-ui`       | Shared UI components + design engine           | `react`, `tailwindcss`                                 |
| `@afena/cli`     | Monorepo tooling (discover, register)          | `commander`, `cosmiconfig`                             |
| `web` (app)      | Next.js 16 application                         | All packages above + Neon Auth/Data API + AWS SDK (R2) |

---

## Key Decisions

1. **Neon Serverless HTTP** over WebSocket/pg — stateless, no pool management, works everywhere.
2. **Drizzle ORM** over Prisma — lighter, SQL-first, better serverless support, schema-as-code.
3. **Neon Auth** over self-hosted Better Auth — zero infra, branches with DB, managed OAuth.
4. **Separate `packages/database`** — centralized schema consumed by all apps, single migration path.
5. **Two DB access patterns** — Drizzle for server (full access), Data API for client (RLS-gated).
6. **Logger middleware decoupled from `next`** — uses generic `MiddlewareRequest` interface to avoid type conflicts from duplicate `next` package instances.

---

## File Storage (Neon + Cloudflare R2)

### Architecture

Files are stored in Cloudflare R2 (S3-compatible, zero egress fees). Metadata is stored in Neon (`r2_files` table with RLS). Upload flow uses presigned URLs — files go directly from browser to R2, never touching the server.

### File Layout

```
apps/web/
├── src/lib/r2.ts                          ← S3Client for R2
├── app/api/storage/
│   ├── presign/route.ts                   ← Generate presigned upload URL
│   └── metadata/route.ts                  ← Save/list file metadata (POST/GET)
packages/database/
└── src/schema.ts                          ← r2_files table with RLS
```

### API Endpoints

| Endpoint                | Method | Purpose                          |
| ----------------------- | ------ | -------------------------------- |
| `/api/storage/presign`  | POST   | Generate presigned R2 upload URL |
| `/api/storage/metadata` | POST   | Save file metadata after upload  |
| `/api/storage/metadata` | GET    | List user's files (RLS-gated)    |

### Environment Variables

```
R2_ACCOUNT_ID              ← Cloudflare account ID
R2_ACCESS_KEY_ID           ← R2 API token access key
R2_SECRET_ACCESS_KEY       ← R2 API token secret
R2_BUCKET_NAME             ← Bucket name (default: axis-attachments)
R2_PUBLIC_BASE_URL         ← Optional: public bucket URL for direct read links
```

### Upload Validation (presign route)

- **Content type whitelist:** images (jpeg/png/gif/webp/svg), PDF, text, CSV, JSON, Word, Excel
- **Max file size:** 50 MB (validated server-side + enforced via `ContentLength` in presigned URL)
- **Presign expiry:** 300s (5 min)

### CORS Policy (`packages/database/scripts/r2-cors.json`)

Restricts browser uploads to allowed origins only.

```json
[
  {
    "AllowedOrigins": [
      "http://localhost:3000",
      "https://nexuscanon.com",
      "https://*.nexuscanon.com"
    ],
    "AllowedMethods": ["PUT"],
    "AllowedHeaders": ["Content-Type"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 3600
  }
]
```

**Status:** Policy file created. Apply with:

```bash
npx wrangler r2 bucket cors set axis-attachments --file packages/database/scripts/r2-cors.json
```

### TODO: UI

File upload UI components are pending the UI kit. The API routes and backend are ready.

---

## Tooling

| Tool                     | Purpose                                    |
| ------------------------ | ------------------------------------------ |
| `psql` (v18.1 via scoop) | Direct SQL access to Neon                  |
| `neonctl`                | Neon CLI (project/branch management)       |
| Neon MCP                 | AI-assisted DB operations via Cascade      |
| `wrangler`               | Cloudflare R2 management (CORS, lifecycle) |

---

## Remaining Configuration

- [x] **File upload UI** — `FileUpload` component in `packages/ui`, `/org/[slug]/files` page, metadata idempotency fix
- [x] **Org Switcher** — `app/components/org-switcher.tsx`, shadcn `dropdown-menu`, server-fetched org list
- [x] **Org Context Provider** — `app/providers/org-context.tsx` + `useOrg()` hook, server-resolved in `OrgLayout`
- [x] **Personal Org Auto-Creation** — `ensurePersonalOrg()` in `src/lib/org.ts`, idempotent via ON CONFLICT
- [x] **Org Dashboard** — `/org/[slug]/page.tsx` with contact/audit/advisory stats
- [x] **Package READMEs** — advisory, canon, crud, search, workflow
- [x] **Schema consolidation** — `schema.ts` → `schema/users.ts` + `schema/r2-files.ts` + `schema/relations.ts`
- [x] **dropdown-menu.tsx TS fix** — `checked ?? false` for `exactOptionalPropertyTypes`
- [x] **ESLint INVARIANT-01 override** — `app/api/storage/**` exempt (system/infra truth)

---

## Beta / Known Limitations

- **Neon Data API** — Beta. PostgREST-compatible REST interface.
- **Neon Auth** — Beta. Built on Better Auth v1.4.6. Check [roadmap](https://neon.com/docs/auth/roadmap).
- **AWS regions only** — Neon Auth doesn't support Azure yet.
- **No IP Allow / Private Networking** with Neon Auth.
- **`@better-auth/passkey`** has unmet peer deps (1.4.18 vs 1.4.6) — cosmetic warning, doesn't affect functionality.

---

## Multi-Tenancy — Completed

Phase 0 (auth helpers, Drizzle policies, schema gate, PRD invariants) + Phase 1 deferred items are now complete.

### Org Infrastructure (implemented)

- **Org Context Provider** — `app/providers/org-context.tsx` (`OrgProvider` + `useOrg()`)
- **Org Switcher** — `app/components/org-switcher.tsx` (shadcn dropdown, server-fetched)
- **Personal Org Auto-Creation** — `ensurePersonalOrg()` in `src/lib/org.ts` (idempotent, ON CONFLICT, no SDK hooks)
- **Org Entry Page** — `/org/page.tsx` redirects to first org or creates personal workspace
- **Org Resolution** — `src/lib/org.ts`: `resolveOrg(slug)`, `listUserOrgs()`, `ensurePersonalOrg()`

### Future Domain Entity Template

- **Pattern established:** `contacts`, `advisories`, `advisory_evidence` all use `tenantPolicy()` + `auth.require_org_id()` DEFAULT + composite indexes + RLS ENABLE/FORCE
- **For new entities:** follow `baseEntityColumns()` + `tenantPolicy()` pattern from `contacts.ts`
