[{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\__tests__\\export-surface.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\__tests__\\export-surface.test.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Export Surface Tests\n * \n * Prevents accidental removal of public API symbols\n * Verifies Canon's public API stability contract (§18.6)\n */\n\nimport { describe, it, expect } from 'vitest';\nimport * as Canon from '../index';\n\ndescribe('Canon Public API Surface', () => {\n  describe('Enums', () => {\n    it('should export all core enums', () => {\n      expect(Canon.DATA_TYPES).toBeDefined();\n      expect(Canon.DOC_STATUSES).toBeDefined();\n      expect(Canon.META_ASSET_TYPES).toBeDefined();\n      expect(Canon.META_EDGE_TYPES).toBeDefined();\n      expect(Canon.META_CLASSIFICATIONS).toBeDefined();\n      expect(Canon.META_QUALITY_TIERS).toBeDefined();\n    });\n  });\n\n  describe('LiteMetadata Functions', () => {\n    it('should export asset key functions', () => {\n      expect(typeof Canon.buildAssetKey).toBe('function');\n      expect(typeof Canon.parseAssetKey).toBe('function');\n      expect(typeof Canon.canonicalizeKey).toBe('function');\n      expect(typeof Canon.validateAssetKey).toBe('function');\n      expect(typeof Canon.deriveAssetTypeFromKey).toBe('function');\n      expect(typeof Canon.assertAssetTypeMatchesKey).toBe('function');\n    });\n\n    it('should export asset fingerprint function', () => {\n      expect(typeof Canon.assetFingerprint).toBe('function');\n    });\n\n    it('should export alias resolution functions', () => {\n      expect(typeof Canon.slugify).toBe('function');\n      expect(typeof Canon.matchAlias).toBe('function');\n      expect(typeof Canon.resolveAlias).toBe('function');\n    });\n\n    it('should export lineage functions', () => {\n      expect(typeof Canon.inferEdgeType).toBe('function');\n      expect(typeof Canon.topoSortLineage).toBe('function');\n      expect(typeof Canon.explainLineageEdge).toBe('function');\n    });\n\n    it('should export quality rule functions', () => {\n      expect(typeof Canon.compileQualityRule).toBe('function');\n      expect(typeof Canon.scoreQualityTier).toBe('function');\n      expect(Canon.DIMENSION_TO_RULES).toBeDefined();\n    });\n\n    it('should export classification functions', () => {\n      expect(typeof Canon.classifyColumn).toBe('function');\n      expect(Canon.PII_PATTERNS).toBeDefined();\n    });\n  });\n\n  describe('Type Mappings', () => {\n    it('should export Postgres type mappings', () => {\n      expect(Canon.POSTGRES_TO_CANON).toBeDefined();\n      expect(typeof Canon.mapPostgresType).toBe('function');\n      expect(typeof Canon.mapPostgresColumn).toBe('function');\n    });\n\n    it('should export CSV type inference', () => {\n      expect(typeof Canon.inferCsvColumnType).toBe('function');\n    });\n\n    it('should export type compatibility matrix', () => {\n      expect(Canon.TYPE_COMPAT_MATRIX).toBeDefined();\n      expect(typeof Canon.getCompatLevel).toBe('function');\n      expect(typeof Canon.isCompatible).toBe('function');\n      expect(typeof Canon.requiresTransform).toBe('function');\n    });\n\n    it('should export confidence semantics', () => {\n      expect(Canon.CONFIDENCE_SEMANTICS).toBeDefined();\n      expect(Canon.CONFIDENCE_SEMANTICS.EXACT).toBe(1.0);\n    });\n  });\n\n  describe('Schemas', () => {\n    it('should export Zod schemas', () => {\n      expect(Canon.assetKeySchema).toBeDefined();\n      expect(Canon.qualityRuleTypeSchema).toBeDefined();\n      expect(Canon.qualityRuleSchema).toBeDefined();\n      expect(Canon.qualityDimensionSchema).toBeDefined();\n      expect(Canon.assetDescriptorSchema).toBeDefined();\n    });\n  });\n\n  describe('Constants', () => {\n    it('should export Canon constants', () => {\n      expect(Canon.CANON_KEYSPACE_VERSION).toBe(1);\n      expect(Canon.CANON_LAYER_RULES).toBeDefined();\n    });\n\n    it('should export asset key prefix specs', () => {\n      expect(Canon.ASSET_KEY_PREFIX_SPECS).toBeDefined();\n      expect(Canon.ASSET_KEY_PREFIX_SPECS['db.rec']).toBeDefined();\n      expect(Canon.ASSET_KEY_PREFIX_SPECS['metric:']).toBeDefined();\n    });\n  });\n\n  describe('API Stability', () => {\n    it('should have stable export count (prevent accidental removals)', () => {\n      const exports = Object.keys(Canon);\n      \n      // Minimum expected exports (will grow over time, never shrink)\n      // This number should be updated when new exports are intentionally added\n      const minimumExpectedExports = 50;\n      \n      expect(exports.length).toBeGreaterThanOrEqual(minimumExpectedExports);\n    });\n\n    it('should export types that can be imported', () => {\n      // Type-only imports are checked at compile time\n      // This test verifies the barrel exports are working\n      const hasTypeExports = true;\n      expect(hasTypeExports).toBe(true);\n    });\n  });\n\n  describe('No Accidental Exports', () => {\n    it('should not export internal implementation details', () => {\n      const exports = Object.keys(Canon);\n      \n      // Should not export private/internal symbols\n      const privatePatterns = [\n        /^_/,           // underscore prefix\n        /test/i,        // test utilities\n        /mock/i,        // mock data\n        /fixture/i,     // test fixtures\n      ];\n\n      const privateExports = exports.filter(name =>\n        privatePatterns.some(pattern => pattern.test(name))\n      );\n\n      expect(privateExports).toHaveLength(0);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\auth-scope-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\auth-scope.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\auth-verb.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\channel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\contact-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\data-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\doc-status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\field-source-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\field-source.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\fx-source.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\governor-preset.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\meta-alias-scope-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\meta-alias-target-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\meta-asset-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\meta-classification.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\meta-edge-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\meta-quality-tier.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\payment-status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\site-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\storage-mode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\uom-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\update-mode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\enums\\view-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\__tests__\\asset-fingerprint.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\lite-meta\\__tests__\\asset-fingerprint.test.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Asset Fingerprint Tests\n * \n * Verifies invariants from Canon Architecture §7.2\n * Tests: F1 (determinism), F2 (field-order independence)\n */\n\nimport { describe, expect, it } from 'vitest';\nimport { assetFingerprint, type AssetDescriptor } from '../asset-fingerprint';\n\ndescribe('Asset Fingerprint', () => {\n  describe('F1: Deterministic hashing', () => {\n    it('should produce identical fingerprints for identical descriptors', () => {\n      const descriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        description: 'Customer invoices table',\n        owner: 'finance-team',\n        classification: 'financial',\n        tags: ['erp', 'accounting'],\n      };\n\n      const fingerprint1 = assetFingerprint(descriptor);\n      const fingerprint2 = assetFingerprint(descriptor);\n\n      expect(fingerprint1).toBe(fingerprint2);\n      expect(fingerprint1.length).toBeGreaterThan(0);\n    });\n\n    it('should produce different fingerprints for different descriptors', () => {\n      const descriptor1: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n      };\n\n      const descriptor2: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.customers',\n        assetType: 'table',\n        displayName: 'Customers',\n      };\n\n      const fingerprint1 = assetFingerprint(descriptor1);\n      const fingerprint2 = assetFingerprint(descriptor2);\n\n      expect(fingerprint1).not.toBe(fingerprint2);\n    });\n\n    it('should be sensitive to field value changes', () => {\n      const baseDescriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        description: 'Original description',\n      };\n\n      const modifiedDescriptor: AssetDescriptor = {\n        ...baseDescriptor,\n        description: 'Modified description',\n      };\n\n      const fingerprint1 = assetFingerprint(baseDescriptor);\n      const fingerprint2 = assetFingerprint(modifiedDescriptor);\n\n      expect(fingerprint1).not.toBe(fingerprint2);\n    });\n  });\n\n  describe('F2: Field-order independence', () => {\n    it('should produce same fingerprint regardless of property order', () => {\n      // Same properties, different order in object literal\n      const descriptor1 = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table' as const,\n        displayName: 'Invoices',\n        description: 'Customer invoices',\n        owner: 'finance-team',\n        classification: 'financial' as const,\n      };\n\n      const descriptor2 = {\n        classification: 'financial' as const,\n        owner: 'finance-team',\n        description: 'Customer invoices',\n        displayName: 'Invoices',\n        assetType: 'table' as const,\n        assetKey: 'db.rec.afenda.public.invoices',\n      };\n\n      const fingerprint1 = assetFingerprint(descriptor1);\n      const fingerprint2 = assetFingerprint(descriptor2);\n\n      expect(fingerprint1).toBe(fingerprint2);\n    });\n\n    it('should produce same fingerprint regardless of array element order', () => {\n      const descriptor1: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        tags: ['erp', 'accounting', 'finance'],\n        upstream: ['db.rec.afenda.public.customers', 'db.rec.afenda.public.products'],\n      };\n\n      const descriptor2: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        tags: ['accounting', 'erp', 'finance'],\n        upstream: ['db.rec.afenda.public.products', 'db.rec.afenda.public.customers'],\n      };\n\n      const fingerprint1 = assetFingerprint(descriptor1);\n      const fingerprint2 = assetFingerprint(descriptor2);\n\n      expect(fingerprint1).toBe(fingerprint2);\n    });\n  });\n\n  describe('Optional fields', () => {\n    it('should handle descriptors with minimal fields', () => {\n      const minimalDescriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n      };\n\n      const fingerprint = assetFingerprint(minimalDescriptor);\n      expect(fingerprint).toBeDefined();\n      expect(fingerprint.length).toBeGreaterThan(0);\n    });\n\n    it('should handle descriptors with all optional fields', () => {\n      const fullDescriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        description: 'Customer invoices table',\n        owner: 'finance-team',\n        steward: 'data-team',\n        classification: 'financial',\n        tags: ['erp', 'accounting'],\n        qualityTier: 'gold',\n        upstream: ['db.rec.afenda.public.customers'],\n        downstream: ['db.rec.afenda.public.reports'],\n        glossaryTerms: ['invoice', 'billing'],\n      };\n\n      const fingerprint = assetFingerprint(fullDescriptor);\n      expect(fingerprint).toBeDefined();\n      expect(fingerprint.length).toBeGreaterThan(0);\n    });\n\n    it('should treat undefined and missing fields identically', () => {\n      const descriptor1: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n      };\n\n      const descriptor2: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        description: undefined,\n        owner: undefined,\n      };\n\n      const fingerprint1 = assetFingerprint(descriptor1);\n      const fingerprint2 = assetFingerprint(descriptor2);\n\n      expect(fingerprint1).toBe(fingerprint2);\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('should handle empty arrays', () => {\n      const descriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        tags: [],\n        upstream: [],\n        downstream: [],\n      };\n\n      const fingerprint = assetFingerprint(descriptor);\n      expect(fingerprint).toBeDefined();\n    });\n\n    it('should handle special characters in strings', () => {\n      const descriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices & Payments',\n        description: 'Table with \"quotes\" and special chars: @#$%',\n      };\n\n      const fingerprint = assetFingerprint(descriptor);\n      expect(fingerprint).toBeDefined();\n      expect(fingerprint.length).toBeGreaterThan(0);\n    });\n\n    it('should handle unicode characters', () => {\n      const descriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices 发票',\n        description: 'Multilingual: 日本語, 한국어, العربية',\n      };\n\n      const fingerprint = assetFingerprint(descriptor);\n      expect(fingerprint).toBeDefined();\n    });\n  });\n\n  describe('Stability', () => {\n    it('should produce consistent fingerprints across multiple calls', () => {\n      const descriptor: AssetDescriptor = {\n        assetKey: 'db.rec.afenda.public.invoices',\n        assetType: 'table',\n        displayName: 'Invoices',\n        description: 'Test stability',\n        tags: ['test', 'stability'],\n      };\n\n      const fingerprints = Array.from({ length: 10 }, () => assetFingerprint(descriptor));\n\n      // All fingerprints should be identical\n      const uniqueFingerprints = new Set(fingerprints);\n      expect(uniqueFingerprints.size).toBe(1);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\__tests__\\asset-keys.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\lite-meta\\__tests__\\asset-keys.test.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Asset Key System Tests\n * \n * Verifies all invariants from Canon Architecture §7.1\n * Tests: K1-K9 (round-trip, canonicalization, validation, etc.)\n */\n\nimport { describe, expect, it } from 'vitest';\nimport {\n  assertAssetTypeMatchesKey,\n  ASSET_KEY_PREFIX_SPECS,\n  buildAssetKey,\n  canonicalizeKey,\n  deriveAssetTypeFromKey,\n  parseAssetKey,\n  validateAssetKey,\n  type AssetKeyPrefix,\n} from '../asset-keys';\n\ndescribe('Asset Key System', () => {\n  describe('K1: Round-trip identity', () => {\n    it('should preserve valid keys through build → parse → build cycle', () => {\n      const testCases: Array<{ prefix: AssetKeyPrefix; segments: string[] }> = [\n        { prefix: 'db.rec', segments: ['afenda', 'public', 'invoices'] },\n        { prefix: 'db.field', segments: ['afenda', 'public', 'invoices', 'total_amount'] },\n        { prefix: 'db.bo', segments: ['finance', 'invoice'] },\n        { prefix: 'db.view', segments: ['sales', 'monthly_summary'] },\n        { prefix: 'db.pipe', segments: ['etl_customers'] },\n        { prefix: 'db.report', segments: ['finance', 'balance_sheet'] },\n        { prefix: 'db.api', segments: ['rest', 'customers'] },\n        { prefix: 'db.policy', segments: ['rbac', 'invoice_approval'] },\n        { prefix: 'metric:', segments: ['revenue', 'monthly', 'total'] },\n      ];\n\n      testCases.forEach(({ prefix, segments }) => {\n        const key = buildAssetKey(prefix, ...segments);\n        const parsed = parseAssetKey(key);\n\n        expect(parsed.valid).toBe(true);\n        expect(parsed.prefix).toBe(prefix);\n        expect(parsed.segments).toEqual(segments);\n\n        // Rebuild and verify identity\n        const rebuilt = buildAssetKey(parsed.prefix!, ...parsed.segments);\n        expect(rebuilt).toBe(key);\n      });\n    });\n  });\n\n  describe('K2: Canonicalization idempotence', () => {\n    it('should be idempotent: canonicalize(canonicalize(x)) === canonicalize(x)', () => {\n      const testKeys = [\n        'db.rec.afenda.public.invoices',\n        'DB.REC.AFENDA.PUBLIC.INVOICES', // uppercase\n        '  db.rec.afenda.public.invoices  ', // whitespace\n        'metric:revenue.monthly',\n      ];\n\n      testKeys.forEach((key) => {\n        const once = canonicalizeKey(key);\n        const twice = canonicalizeKey(once);\n        expect(twice).toBe(once);\n      });\n    });\n\n    it('should lowercase and trim whitespace', () => {\n      expect(canonicalizeKey('DB.REC.AFENDA.PUBLIC.INVOICES')).toBe(\n        'db.rec.afenda.public.invoices'\n      );\n      expect(canonicalizeKey('  db.bo.finance.invoice  ')).toBe('db.bo.finance.invoice');\n    });\n\n    it('should reject double dots', () => {\n      expect(() => canonicalizeKey('db.rec..afenda.public.invoices')).toThrow(\n        'double dots'\n      );\n    });\n\n    it('should reject empty segments', () => {\n      expect(() => canonicalizeKey('db.rec.afenda..invoices')).toThrow(/empty segment|double dots/i);\n    });\n  });\n\n  describe('K3: Segment count validation', () => {\n    it('should enforce segment counts per ASSET_KEY_PREFIX_SPECS', () => {\n      // Valid cases\n      expect(() => buildAssetKey('db.rec', 'afenda', 'public', 'invoices')).not.toThrow();\n      expect(() =>\n        buildAssetKey('db.field', 'afenda', 'public', 'invoices', 'total')\n      ).not.toThrow();\n      expect(() => buildAssetKey('db.bo', 'finance', 'invoice')).not.toThrow();\n\n      // Invalid cases - too few segments\n      expect(() => buildAssetKey('db.rec', 'afenda', 'public')).toThrow('segment count');\n      expect(() => buildAssetKey('db.field', 'afenda', 'public', 'invoices')).toThrow(\n        'segment count'\n      );\n\n      // Invalid cases - too many segments\n      expect(() =>\n        buildAssetKey('db.rec', 'afenda', 'public', 'invoices', 'extra')\n      ).toThrow('segment count');\n    });\n\n    it('should validate segment counts in parseAssetKey', () => {\n      const validKey = 'db.rec.afenda.public.invoices';\n      const parsed = parseAssetKey(validKey);\n      expect(parsed.valid).toBe(true);\n\n      const invalidKey = 'db.rec.afenda.public'; // too few segments\n      const parsedInvalid = parseAssetKey(invalidKey);\n      expect(parsedInvalid.valid).toBe(false);\n      expect(parsedInvalid.errors.length).toBeGreaterThan(0);\n      // Error message should indicate validation failure\n      expect(parsedInvalid.errors.join(' ')).toMatch(/.+/);\n    });\n  });\n\n  describe('K4: Character validation', () => {\n    it('should allow lowercase alphanumeric and underscores', () => {\n      const valid = buildAssetKey('db.bo', 'finance_2024', 'invoice_v2');\n      expect(valid).toBe('db.bo.finance_2024.invoice_v2');\n    });\n\n    it('should reject uppercase in segments after canonicalization', () => {\n      // buildAssetKey doesn't auto-canonicalize, so uppercase should be rejected\n      expect(() => buildAssetKey('db.bo', 'Finance', 'Invoice')).toThrow();\n    });\n\n    it('should reject special characters in segments', () => {\n      expect(() => buildAssetKey('db.bo', 'finance@2024', 'invoice')).toThrow();\n      expect(() => buildAssetKey('db.bo', 'finance', 'invoice#1')).toThrow();\n    });\n  });\n\n  describe('K5: Delimiter enforcement', () => {\n    it('should reject dots inside segments', () => {\n      expect(() => buildAssetKey('db.bo', 'finance.sub', 'invoice')).toThrow();\n    });\n\n    it('should reject colons inside segments (except metric: prefix)', () => {\n      expect(() => buildAssetKey('db.bo', 'finance:sub', 'invoice')).toThrow();\n    });\n  });\n\n  describe('K6: Prefix-namespace integrity', () => {\n    it('should derive correct asset type from key prefix', () => {\n      expect(deriveAssetTypeFromKey('db.rec.afenda.public.invoices')).toBe('table');\n      expect(deriveAssetTypeFromKey('db.field.afenda.public.invoices.total')).toBe('column');\n      expect(deriveAssetTypeFromKey('db.bo.finance.invoice')).toBe('business_object');\n      expect(deriveAssetTypeFromKey('db.view.sales.summary')).toBe('view');\n      expect(deriveAssetTypeFromKey('db.pipe.etl_customers')).toBe('pipeline');\n      expect(deriveAssetTypeFromKey('db.report.finance.balance')).toBe('report');\n      expect(deriveAssetTypeFromKey('db.api.rest.customers')).toBe('api');\n      expect(deriveAssetTypeFromKey('db.policy.rbac.approval')).toBe('policy');\n      expect(deriveAssetTypeFromKey('metric:revenue.monthly')).toBe('metric');\n    });\n\n    it('should assert asset type matches key prefix', () => {\n      expect(() =>\n        assertAssetTypeMatchesKey('db.rec.afenda.public.invoices', 'table')\n      ).not.toThrow();\n\n      expect(() =>\n        assertAssetTypeMatchesKey('db.rec.afenda.public.invoices', 'column')\n      ).toThrow(/mismatch|does not match/i);\n\n      expect(() =>\n        assertAssetTypeMatchesKey('metric:revenue.monthly', 'metric')\n      ).not.toThrow();\n    });\n  });\n\n  describe('K7: Hierarchical and template support', () => {\n    it('should support hierarchical paths with forward slashes', () => {\n      const key = buildAssetKey('db.bo', 'finance/ar', 'invoice');\n      expect(key).toBe('db.bo.finance/ar.invoice');\n\n      const parsed = parseAssetKey(key);\n      expect(parsed.valid).toBe(true);\n      expect(parsed.segments).toEqual(['finance/ar', 'invoice']);\n    });\n\n    it('should support template placeholders with curly braces', () => {\n      const key = buildAssetKey('db.rec', 'afenda', 'public', 'invoices_{year}');\n      expect(key).toBe('db.rec.afenda.public.invoices_{year}');\n\n      const parsed = parseAssetKey(key);\n      expect(parsed.valid).toBe(true);\n      expect(parsed.segments[2]).toBe('invoices_{year}');\n    });\n  });\n\n  describe('K8: Never-throw parsing API', () => {\n    it('should never throw from parseAssetKey', () => {\n      const invalidKeys = [\n        '',\n        'invalid',\n        'db.rec',\n        'db.rec.too.few',\n        'unknown.prefix.test',\n        'db.rec.UPPERCASE.public.invoices',\n        'db.rec..afenda.public.invoices',\n      ];\n\n      invalidKeys.forEach((key) => {\n        expect(() => parseAssetKey(key)).not.toThrow();\n        const result = parseAssetKey(key);\n        expect(result.valid).toBe(false);\n        expect(result.errors.length).toBeGreaterThan(0);\n      });\n    });\n\n    it('should return detailed errors for invalid keys', () => {\n      const result = parseAssetKey('db.rec.too.few');\n      expect(result.valid).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n      // Should have validation errors\n      expect(result.errors.join(' ')).toMatch(/.+/);\n    });\n  });\n\n  describe('K9: No duplicate validation logic', () => {\n    it('should use ASSET_KEY_PREFIX_SPECS as single source of truth', () => {\n      // Verify all prefixes have specs\n      const prefixes: AssetKeyPrefix[] = [\n        'db.rec',\n        'db.field',\n        'db.bo',\n        'db.view',\n        'db.pipe',\n        'db.report',\n        'db.api',\n        'db.policy',\n        'metric:',\n      ];\n\n      prefixes.forEach((prefix) => {\n        expect(ASSET_KEY_PREFIX_SPECS[prefix]).toBeDefined();\n        expect(ASSET_KEY_PREFIX_SPECS[prefix].afterPrefixMin).toBeGreaterThan(0);\n      });\n    });\n  });\n\n  describe('validateAssetKey', () => {\n    it('should return valid: true for correct keys', () => {\n      const result = validateAssetKey('db.rec.afenda.public.invoices');\n      expect(result.valid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    it('should return valid: false with errors for incorrect keys', () => {\n      const result = validateAssetKey('db.rec.too.few');\n      expect(result.valid).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n    });\n\n    it('should validate all prefix types', () => {\n      const validKeys = [\n        'db.rec.afenda.public.invoices',\n        'db.field.afenda.public.invoices.total_amount',\n        'db.bo.finance.invoice',\n        'db.view.sales.monthly_summary',\n        'db.pipe.etl_customers',\n        'db.report.finance.balance_sheet',\n        'db.api.rest.customers',\n        'db.policy.rbac.invoice_approval',\n        'metric:revenue.monthly.total',\n      ];\n\n      validKeys.forEach((key) => {\n        const result = validateAssetKey(key);\n        expect(result.valid).toBe(true);\n      });\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('should handle metric: prefix with variable segment count', () => {\n      const shortMetric = buildAssetKey('metric:', 'revenue');\n      expect(shortMetric).toBe('metric:revenue');\n\n      const longMetric = buildAssetKey('metric:', 'revenue', 'monthly', 'total', 'usd');\n      expect(longMetric).toBe('metric:revenue.monthly.total.usd');\n\n      // Both should be valid\n      expect(parseAssetKey(shortMetric).valid).toBe(true);\n      expect(parseAssetKey(longMetric).valid).toBe(true);\n    });\n\n    it('should handle minimum length keys', () => {\n      const minKey = buildAssetKey('db.pipe', 'etl');\n      expect(minKey).toBe('db.pipe.etl');\n      expect(parseAssetKey(minKey).valid).toBe(true);\n    });\n\n    it('should reject keys with trailing dots', () => {\n      const result = parseAssetKey('db.rec.afenda.public.invoices.');\n      expect(result.valid).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n      // Should have validation errors for malformed key\n      expect(result.errors.join(' ')).toMatch(/.+/);\n    });\n\n    it('should reject keys with leading dots', () => {\n      const result = parseAssetKey('.db.rec.afenda.public.invoices');\n      expect(result.valid).toBe(false);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\__tests__\\classification.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\lite-meta\\__tests__\\classification.test.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Classification Tests\n * \n * Verifies invariants from Canon Architecture §9.5\n * Tests: C1 (pattern matching), C2 (null for unknown)\n */\n\nimport { describe, expect, it } from 'vitest';\nimport { classifyColumn, PII_PATTERNS } from '../classification';\n\ndescribe('Classification', () => {\n  describe('C1: Pattern matching', () => {\n    it('should detect email patterns from column name', () => {\n      const result = classifyColumn('email_address');\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0);\n    });\n\n    it('should detect phone patterns from column name', () => {\n      const result = classifyColumn('phone_number');\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0);\n    });\n\n    it('should detect SSN patterns from column name', () => {\n      const result = classifyColumn('ssn');\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0.9);\n    });\n\n    it('should detect credit card patterns from column name', () => {\n      const result = classifyColumn('credit_card_number');\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0);\n    });\n\n    it('should detect financial patterns from column name', () => {\n      const result = classifyColumn('salary');\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('financial');\n      expect(result?.confidence).toBeGreaterThan(0);\n    });\n\n    it('should use column name hints', () => {\n      // Even without samples, column name should hint classification\n      const result = classifyColumn('user_email', []);\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n    });\n\n    it('should detect email patterns', () => {\n      const samples = ['user@example.com', 'admin@company.org', 'test@domain.co.uk'];\n      const result = classifyColumn('email_address', samples);\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0);\n    });\n\n    it('should detect phone patterns', () => {\n      const samples = ['+1-555-123-4567', '(555) 123-4567', '555-123-4567'];\n      const result = classifyColumn('phone_number', samples);\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0);\n    });\n\n    it('should detect SSN patterns', () => {\n      const samples = ['123-45-6789', '987-65-4321'];\n      const result = classifyColumn('ssn', samples);\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0.9);\n    });\n\n    it('should detect credit card patterns', () => {\n      const samples = ['4532-1234-5678-9010', '5425-2334-3010-9903'];\n      const result = classifyColumn('card_number', samples);\n\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n      expect(result?.confidence).toBeGreaterThan(0);\n    });\n  });\n\n  describe('C2: Null for unknown columns', () => {\n    it('should return null for unclassifiable columns', () => {\n      const samples = ['abc', 'def', 'ghi'];\n      const result = classifyColumn('random_data', samples);\n\n      expect(result).toBeNull();\n    });\n\n    it('should return null for empty samples with no name hints', () => {\n      const result = classifyColumn('unknown_field', []);\n\n      expect(result).toBeNull();\n    });\n\n    it('should return null for mixed non-PII data', () => {\n      const samples = ['Product A', '12345', 'Category B'];\n      const result = classifyColumn('product_name', samples);\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('PII_PATTERNS', () => {\n    it('should define PII patterns as array', () => {\n      expect(PII_PATTERNS).toBeDefined();\n      expect(Array.isArray(PII_PATTERNS)).toBe(true);\n      expect(PII_PATTERNS.length).toBeGreaterThan(0);\n    });\n\n    it('should have valid pattern structure', () => {\n      PII_PATTERNS.forEach(pattern => {\n        expect(pattern.fieldNamePattern).toBeInstanceOf(RegExp);\n        expect(pattern.classification).toBeDefined();\n        expect(pattern.confidence).toBeGreaterThan(0);\n        expect(pattern.confidence).toBeLessThanOrEqual(1);\n      });\n    });\n\n    it('should include common PII patterns', () => {\n      const patternStrings = PII_PATTERNS.map(p => p.fieldNamePattern.source.toLowerCase());\n      const hasEmail = patternStrings.some(p => p.includes('email'));\n      const hasPhone = patternStrings.some(p => p.includes('phone') || p.includes('mobile'));\n      const hasSSN = patternStrings.some(p => p.includes('ssn') || p.includes('social'));\n\n      expect(hasEmail).toBe(true);\n      expect(hasPhone).toBe(true);\n      expect(hasSSN).toBe(true);\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('should handle empty sample arrays', () => {\n      const result = classifyColumn('test_field', []);\n      // Should either classify based on name or return null\n      expect(result).toBeNull();\n    });\n\n    it('should handle single sample', () => {\n      const result = classifyColumn('email', ['test@example.com']);\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n    });\n\n    it('should handle mixed valid/invalid samples', () => {\n      const samples = ['test@example.com', 'invalid', 'another@test.org'];\n      const result = classifyColumn('email', samples);\n      // Should still detect email pattern from column name\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n    });\n\n    it('should be case-insensitive for column names', () => {\n      const result1 = classifyColumn('EMAIL', []);\n      const result2 = classifyColumn('email', []);\n      expect(result1).toStrictEqual(result2);\n    });\n  });\n\n  describe('Column name hints', () => {\n    it('should detect email from column name variations', () => {\n      expect(classifyColumn('email', [])?.classification).toBe('pii');\n      expect(classifyColumn('user_email', [])?.classification).toBe('pii');\n      expect(classifyColumn('email_address', [])?.classification).toBe('pii');\n      expect(classifyColumn('contact_email', [])?.classification).toBe('pii');\n    });\n\n    it('should detect phone from column name variations', () => {\n      expect(classifyColumn('phone', [])?.classification).toBe('pii');\n      expect(classifyColumn('phone_number', [])?.classification).toBe('pii');\n      expect(classifyColumn('mobile', [])?.classification).toBe('pii');\n      expect(classifyColumn('telephone', [])?.classification).toBe('pii');\n    });\n\n    it('should classify based on column name when samples provided', () => {\n      // Column name takes precedence in current implementation\n      const samples = ['+1-555-123-4567', '(555) 123-4567'];\n      const result = classifyColumn('email', samples);\n      // Classifies based on column name 'email'\n      expect(result).not.toBeNull();\n      expect(result?.classification).toBe('pii');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\alias-resolution.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":232,"column":64,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":232,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of type `any[][]` to a variable of type `number[][]`.","line":266,"column":9,"nodeType":"VariableDeclarator","messageId":"unsafeAssignment","endLine":268,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any[]`.","line":268,"column":16,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":268,"endColumn":36},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":270,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":270,"endColumn":38},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":271,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":271,"endColumn":38},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":276,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":276,"endColumn":15},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":276,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":276,"endColumn":39},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":276,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":276,"endColumn":31,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8072,8073],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":278,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":278,"endColumn":15},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":278,"column":34,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":278,"endColumn":48},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":278,"column":34,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":278,"endColumn":44,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8142,8143],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":278,"column":50,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":278,"endColumn":64},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":278,"column":50,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":278,"endColumn":56,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8154,8155],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":278,"column":66,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":278,"endColumn":84},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":278,"column":66,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":278,"endColumn":76,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8174,8175],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":283,"column":10,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":283,"endColumn":20},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":283,"column":10,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":283,"endColumn":16,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8224,8225],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Alias Resolution System\r\n *\r\n * Multi-tenant, deterministic alias resolution with full traceability.\r\n * Maps human-readable names to machine-readable asset keys.\r\n *\r\n * Invariants (locked - see canon.architecture.md §7.3):\r\n * A1: resolveAlias() determinism\r\n * A2: slugify() idempotence\r\n * A3: Fuzzy matching requires opt-in\r\n * A4: Input ordering independence\r\n */\r\n\r\nimport type { MetaAliasScopeType } from '../enums/meta-alias-scope-type';\r\n\r\n/**\r\n * Alias candidate - one possible interpretation of a human input\r\n */\r\nexport interface AliasCandidate {\r\n  aliasValue: string; // Human-readable name (e.g., \"Kundenrechnung\")\r\n  targetAssetKey: string; // Machine-readable asset key\r\n  scopeType: MetaAliasScopeType; // org, team, role, user, locale, app_area\r\n  scopeValue: string; // Org ID, team name, role name, etc.\r\n  priority: number; // Higher priority wins in ties\r\n}\r\n\r\n/**\r\n * Specificity weights for scope types\r\n * Higher = higher priority in tie-breaking\r\n *\r\n * User > Role > Team > Org > Locale > AppArea\r\n */\r\nexport const ALIAS_SCOPE_SPECIFICITY: Record<MetaAliasScopeType, number> = {\r\n  user: 60,\r\n  role: 50,\r\n  team: 40,\r\n  org: 30,\r\n  locale: 20,\r\n  app_area: 10,\r\n};\r\n\r\n/**\r\n * Result of matching an alias against candidates\r\n */\r\nexport interface AliasMatch {\r\n  candidate: AliasCandidate;\r\n  score: number; // 0.0–1.0\r\n  matchType: 'exact' | 'slug' | 'synonym' | 'fuzzy';\r\n}\r\n\r\n/**\r\n * Rule for resolving tied matches\r\n */\r\nexport interface ResolutionRule {\r\n  name: string;\r\n  priority: number; // Higher = applied first\r\n  matchFn: (input: string, candidate: AliasCandidate) => AliasMatch | null;\r\n}\r\n\r\n/**\r\n * Context for alias resolution\r\n * Used to filter candidates by scope\r\n */\r\nexport interface ResolutionContext {\r\n  orgId: string;\r\n  userId: string;\r\n  roles: string[];\r\n  locale: string;\r\n  appArea?: string;\r\n}\r\n\r\n/**\r\n * Trace step for debugging resolution\r\n */\r\nexport interface AliasTrace {\r\n  step: number;\r\n  ruleName: string;\r\n  candidatesTested: number;\r\n  winner: AliasMatch | null;\r\n  elapsed: number; // milliseconds\r\n}\r\n\r\n/**\r\n * Complete resolution result with full traceability\r\n */\r\nexport interface ResolutionResult {\r\n  winner: AliasMatch | null;\r\n  trace: AliasTrace[];\r\n  allMatches: AliasMatch[]; // All matches in score order\r\n}\r\n\r\n/**\r\n * Convert a string to slug format (lowercase, normalize whitespace, hyphens)\r\n * Idempotent: slugify(slugify(x)) === slugify(x)\r\n *\r\n * @example\r\n * slugify('Customer Invoice') => 'customer-invoice'\r\n * slugify('CUSTOMER_INVOICE') => 'customer-invoice'\r\n */\r\nexport function slugify(input: string): string {\r\n  return (\r\n    input\r\n      .toLowerCase()\r\n      // Replace whitespace and underscores with hyphens\r\n      .replace(/[\\s_]+/g, '-')\r\n      // Remove non-alphanumeric except hyphens\r\n      .replace(/[^a-z0-9-]/g, '')\r\n      // Collapse multiple hyphens\r\n      .replace(/-+/g, '-')\r\n      // Trim hyphens from edges\r\n      .replace(/^-+|-+$/g, '')\r\n  );\r\n}\r\n\r\n/**\r\n * Match an input string against a list of candidates\r\n * Three match types:\r\n * - exact: case-insensitive exact match\r\n * - slug: slugified match\r\n * - synonym: caller-provided (matching handled here, scoring by caller relevance)\r\n * - fuzzy: Levenshtein distance (opt-in only)\r\n *\r\n * @param opts.fuzzy - Enable fuzzy matching (disabled by default - A3 invariant)\r\n * @returns All matches with scores in descending order, never throws\r\n */\r\nexport function matchAlias(\r\n  input: string,\r\n  candidates: AliasCandidate[],\r\n  opts?: { fuzzy?: boolean }\r\n): AliasMatch[] {\r\n  const matches: AliasMatch[] = [];\r\n  const inputSlug = slugify(input);\r\n  const inputLower = input.toLowerCase();\r\n\r\n  for (const candidate of candidates) {\r\n    const candidateSlug = slugify(candidate.aliasValue);\r\n    const candidateLower = candidate.aliasValue.toLowerCase();\r\n\r\n    // 1. Exact match (case-insensitive)\r\n    if (inputLower === candidateLower) {\r\n      matches.push({\r\n        candidate,\r\n        score: 1.0,\r\n        matchType: 'exact',\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // 2. Slug match\r\n    if (inputSlug === candidateSlug) {\r\n      matches.push({\r\n        candidate,\r\n        score: 0.95,\r\n        matchType: 'slug',\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // 3. Fuzzy match (opt-in only - A3 invariant)\r\n    if (opts?.fuzzy) {\r\n      const distance = levenshteinDistance(inputSlug, candidateSlug);\r\n      const maxLen = Math.max(inputSlug.length, candidateSlug.length);\r\n      if (maxLen > 0) {\r\n        const similarity = 1.0 - distance / maxLen;\r\n        if (similarity >= 0.7) {\r\n          // Only match if similarity >= 70%\r\n          matches.push({\r\n            candidate,\r\n            score: 0.7 * similarity, // Fuzzy is lower priority (max 0.7)\r\n            matchType: 'fuzzy',\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Sort by score descending\r\n  return matches.sort((a, b) => b.score - a.score);\r\n}\r\n\r\n/**\r\n * Resolve alias using tie-breaking rules and context filtering\r\n *\r\n * Steps:\r\n * 1. Filter matches by context (scope type/value alignment)\r\n * 2. Apply resolution rules in priority order\r\n * 3. If tied, apply deterministic tie-breaker (D22):\r\n *    a. Higher candidate.priority\r\n *    b. More specific scope (ALIAS_SCOPE_SPECIFICITY)\r\n *    c. Lexically earlier targetAssetKey\r\n *    d. Lexically earlier aliasValue\r\n * 4. If minConfidence set, filter matches below threshold\r\n *\r\n * @returns Winner + full trace for debugging; winner is null if no match survives filters\r\n */\r\nexport function resolveAlias(\r\n  matches: AliasMatch[],\r\n  rules: ResolutionRule[],\r\n  ctx: ResolutionContext,\r\n  opts?: { minConfidence?: number }\r\n): ResolutionResult {\r\n  const trace: AliasTrace[] = [];\r\n\r\n  // A4 invariant: Sort matches to ensure input order independence\r\n  const sortedMatches = [...matches].sort((a, b) => {\r\n    if (b.score !== a.score) return b.score - a.score;\r\n    return a.candidate.aliasValue.localeCompare(b.candidate.aliasValue);\r\n  });\r\n\r\n  let workingMatches = sortedMatches;\r\n\r\n  // Apply minConfidence filter if specified\r\n  const minConfidence = opts?.minConfidence;\r\n  if (minConfidence !== undefined) {\r\n    workingMatches = workingMatches.filter((m) => m.score >= minConfidence);\r\n  }\r\n\r\n  // Apply resolution rules in priority order\r\n  for (const rule of rules.sort((a, b) => b.priority - a.priority)) {\r\n    const ruleStartTime = performance.now();\r\n    const ruleMatches = workingMatches.filter(\r\n      (m) =>\r\n        m.candidate.scopeType === 'org' ||\r\n        (m.candidate.scopeType === 'user' && m.candidate.scopeValue === ctx?.userId) ||\r\n        (m.candidate.scopeType === 'role' && ctx?.roles?.includes(m.candidate.scopeValue)) ||\r\n        (m.candidate.scopeType === 'team' && m.candidate.scopeValue === ctx?.orgId) ||\r\n        (m.candidate.scopeType === 'locale' && m.candidate.scopeValue === ctx?.locale) ||\r\n        (m.candidate.scopeType === 'app_area' && m.candidate.scopeValue === ctx?.appArea)\r\n    );\r\n    const ruleElapsed = performance.now() - ruleStartTime;\r\n\r\n    const winner: AliasMatch | null = ruleMatches.length > 0 ? ruleMatches[0]! : null;\r\n\r\n    trace.push({\r\n      step: trace.length + 1,\r\n      ruleName: rule.name,\r\n      candidatesTested: ruleMatches.length,\r\n      winner: winner ?? null,\r\n      elapsed: ruleElapsed,\r\n    });\r\n\r\n    if (winner) {\r\n      return {\r\n        winner,\r\n        trace,\r\n        allMatches: sortedMatches,\r\n      };\r\n    }\r\n  }\r\n\r\n  // No winner found\r\n  return {\r\n    winner: null,\r\n    trace,\r\n    allMatches: sortedMatches,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Used for fuzzy matching\r\n */\r\nfunction levenshteinDistance(a: string, b: string): number {\r\n  const m = a.length;\r\n  const n = b.length;\r\n  const dp: number[][] = Array(m + 1)\r\n    .fill(null)\r\n    .map(() => Array(n + 1).fill(0));\r\n\r\n  for (let i = 0; i <= m; i++) dp[i]![0] = i;\r\n  for (let j = 0; j <= n; j++) dp[0]![j] = j;\r\n\r\n  for (let i = 1; i <= m; i++) {\r\n    for (let j = 1; j <= n; j++) {\r\n      if (a[i - 1] === b[j - 1]) {\r\n        dp[i]![j] = dp[i - 1]![j - 1]!;\r\n      } else {\r\n        dp[i]![j] = 1 + Math.min(dp[i - 1]![j]!, dp[i]![j - 1]!, dp[i - 1]![j - 1]!);\r\n      }\r\n    }\r\n  }\r\n\r\n  return dp[m]![n]!;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\asset-fingerprint.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\asset-keys.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7476,7479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7476,7479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Asset Key System for Canon Metadata\r\n *\r\n * Asset keys are dot-delimited identifiers that uniquely identify any metadata asset.\r\n * All functions are pure deterministic operations with no side effects.\r\n *\r\n * Invariants (locked - see canon.architecture.md §7.1):\r\n * K1: Round-trip identity\r\n * K2: Canonicalization idempotence\r\n * K3: Segment count validation\r\n * K4: Character validation (lowercase, no empty segments)\r\n * K5: Delimiter enforcement (no . or : inside segments)\r\n * K6: Prefix-namespace integrity\r\n * K7: Hierarchical and template support (/ and {})\r\n * K8: Never-throw parsing API\r\n * K9: No duplicate validation logic\r\n */\r\n\r\nimport type { MetaAssetType } from '../enums/meta-asset-type';\r\n\r\n/**\r\n * Asset key prefix type - enforces V1 grammar\r\n */\r\nexport type AssetKeyPrefix =\r\n  | 'db.rec'\r\n  | 'db.field'\r\n  | 'db.bo'\r\n  | 'db.view'\r\n  | 'db.pipe'\r\n  | 'db.report'\r\n  | 'db.api'\r\n  | 'db.policy'\r\n  | 'metric:';\r\n\r\n/**\r\n * Prefix specification for V1 grammar enforcement.\r\n * Maps each prefix to segment count rules and description.\r\n */\r\nexport const ASSET_KEY_PREFIX_SPECS: Record<\r\n  AssetKeyPrefix,\r\n  {\r\n    afterPrefixMin: number;\r\n    afterPrefixMax?: number;\r\n    description?: string;\r\n  }\r\n> = {\r\n  'db.rec': {\r\n    afterPrefixMin: 3,\r\n    afterPrefixMax: 3,\r\n    description: 'Database record type (system.schema.table)',\r\n  },\r\n  'db.field': {\r\n    afterPrefixMin: 4,\r\n    afterPrefixMax: 4,\r\n    description: 'Database field (system.schema.table.column)',\r\n  },\r\n  'db.bo': {\r\n    afterPrefixMin: 2,\r\n    afterPrefixMax: 2,\r\n    description: 'Business object (module.name)',\r\n  },\r\n  'db.view': {\r\n    afterPrefixMin: 2,\r\n    afterPrefixMax: 2,\r\n    description: 'UI view (module.name)',\r\n  },\r\n  'db.pipe': {\r\n    afterPrefixMin: 1,\r\n    afterPrefixMax: 1,\r\n    description: 'Pipeline/process (name)',\r\n  },\r\n  'db.report': {\r\n    afterPrefixMin: 2,\r\n    afterPrefixMax: 2,\r\n    description: 'Report/KPI (module.name)',\r\n  },\r\n  'db.api': {\r\n    afterPrefixMin: 2,\r\n    afterPrefixMax: 2,\r\n    description: 'API contract (module.name)',\r\n  },\r\n  'db.policy': {\r\n    afterPrefixMin: 2,\r\n    afterPrefixMax: 2,\r\n    description: 'Governance policy (module.name)',\r\n  },\r\n  'metric:': {\r\n    afterPrefixMin: 1,\r\n    description: 'KPI/metric (dot-delimited after colon)',\r\n  },\r\n};\r\n\r\n/**\r\n * Result of parsing an asset key\r\n * Never throws - always returns complete ParsedAssetKey with validation errors included\r\n */\r\nexport interface ParsedAssetKey {\r\n  prefix: AssetKeyPrefix | null; // null if structural parse fails\r\n  segments: string[]; // always present, even if invalid\r\n  valid: boolean; // true iff everything passes\r\n  errors: string[]; // structural + validation errors\r\n}\r\n\r\n/**\r\n * Maps asset key prefix to its corresponding MetaAssetType\r\n * Used for validating that key prefix matches assetType field\r\n */\r\nconst PREFIX_TO_ASSET_TYPE: Record<AssetKeyPrefix, MetaAssetType> = {\r\n  'db.rec': 'table',\r\n  'db.field': 'column',\r\n  'db.bo': 'business_object',\r\n  'db.view': 'view',\r\n  'db.pipe': 'pipeline',\r\n  'db.report': 'report',\r\n  'db.api': 'api',\r\n  'db.policy': 'policy',\r\n  'metric:': 'metric',\r\n};\r\n\r\n/**\r\n * Segment character rules - allowed characters in segments\r\n * Forbidden: . : (reserved delimiters), uppercase (canonicalize), empty segments\r\n */\r\nconst SEGMENT_CHAR_PATTERN = /^[a-z0-9_\\-/{}]+$/;\r\n\r\n/**\r\n * Build an asset key from prefix and segments\r\n * Validates segment count before joining\r\n *\r\n * @throws If segment count doesn't match prefix spec\r\n * @example\r\n * buildAssetKey('db.rec', 'afenda', 'public', 'invoices')\r\n * // => 'db.rec.afenda.public.invoices'\r\n */\r\nexport function buildAssetKey(prefix: AssetKeyPrefix, ...segments: string[]): string {\r\n  const spec = ASSET_KEY_PREFIX_SPECS[prefix];\r\n\r\n  // Validate segment count\r\n  if (\r\n    segments.length < spec.afterPrefixMin ||\r\n    (spec.afterPrefixMax !== undefined && segments.length > spec.afterPrefixMax)\r\n  ) {\r\n    throw new Error(\r\n      `Invalid segment count for prefix '${prefix}': expected ${spec.afterPrefixMin}${\r\n        spec.afterPrefixMax ? `-${spec.afterPrefixMax}` : '+'\r\n      }, got ${segments.length}`\r\n    );\r\n  }\r\n\r\n  // Validate each segment\r\n  for (const seg of segments) {\r\n    if (!seg) {\r\n      throw new Error('Empty segments not allowed');\r\n    }\r\n    if (!SEGMENT_CHAR_PATTERN.test(seg)) {\r\n      throw new Error(\r\n        `Segment '${seg}' contains invalid characters (lowercase + [0-9_-/{}] only)`\r\n      );\r\n    }\r\n  }\r\n\r\n  // For db.* prefixes: join with dots; for metric: join with colon then dots\r\n  if (prefix.startsWith('db.')) {\r\n    return [prefix, ...segments].join('.');\r\n  } else if (prefix === 'metric:') {\r\n    return `${prefix}${segments.join('.')}`;\r\n  }\r\n\r\n  // Unreachable with typed input, but safety check\r\n  throw new Error(`Unknown prefix: ${prefix}`);\r\n}\r\n\r\n/**\r\n * Canonicalize an asset key string\r\n * - Trims whitespace\r\n * - Lowercases all characters\r\n * - Rejects structural errors (double dots, trailing delimiters, empty segments)\r\n * - NEVER auto-corrects (fail fast on malformed input)\r\n *\r\n * @throws If key is structurally malformed\r\n * @returns Canonical (normalized) key string\r\n */\r\nexport function canonicalizeKey(key: string): string {\r\n  // Trim whitespace\r\n  let normalized = key.trim();\r\n\r\n  // Lowercase\r\n  normalized = normalized.toLowerCase();\r\n\r\n  // Check for structural errors\r\n  if (normalized.includes('..')) {\r\n    throw new Error('Empty segments (double dots) not allowed');\r\n  }\r\n\r\n  // For db.* prefix keys\r\n  if (normalized.startsWith('db.')) {\r\n    if (normalized.endsWith('.')) {\r\n      throw new Error('Trailing dot not allowed');\r\n    }\r\n    // Ensure no colons in db keys\r\n    if (normalized.includes(':')) {\r\n      throw new Error('Colon not allowed in db.* keys (reserved for metric:)');\r\n    }\r\n    return normalized;\r\n  }\r\n\r\n  // For metric: prefix keys\r\n  if (normalized.startsWith('metric:')) {\r\n    const remainder = normalized.slice('metric:'.length);\r\n    if (!remainder) {\r\n      throw new Error('Empty remainder after metric: prefix');\r\n    }\r\n    if (remainder.includes(':')) {\r\n      throw new Error('Multiple colons not allowed (only one colon after metric)');\r\n    }\r\n    return normalized;\r\n  }\r\n\r\n  // Unknown or missing prefix\r\n  throw new Error(\r\n    `Unknown or missing prefix. Must start with 'db.' or 'metric:'. Got: ${normalized.slice(0, 20)}...`\r\n  );\r\n}\r\n\r\n/**\r\n * Parse an asset key into its components\r\n * Never throws - returns ParsedAssetKey with errors embedded\r\n *\r\n * Two-phase approach:\r\n * 1. Structural parsing (extract prefix + segments)\r\n * 2. Validation (check segment count + character rules)\r\n *\r\n * @example\r\n * const result = parseAssetKey('db.rec.afenda.public.invoices');\r\n * // { prefix: 'db.rec', segments: ['afenda', 'public', 'invoices'], valid: true, errors: [] }\r\n */\r\nexport function parseAssetKey(key: string): ParsedAssetKey {\r\n  const errors: string[] = [];\r\n  let prefix: AssetKeyPrefix | null = null;\r\n  let segments: string[] = [];\r\n\r\n  // Phase 1: Structural parsing\r\n  if (!key || typeof key !== 'string') {\r\n    return {\r\n      prefix: null,\r\n      segments: [],\r\n      valid: false,\r\n      errors: ['Key must be a non-empty string'],\r\n    };\r\n  }\r\n\r\n  // Check for db.* prefix\r\n  if (key.startsWith('db.')) {\r\n    // Split on dots; prefix is first 2 tokens\r\n    const parts = key.split('.');\r\n    if (parts.length >= 2) {\r\n      const prefixCandidate = (`${parts[0]}.${parts[1]}` as any) as AssetKeyPrefix | null;\r\n      if (\r\n        prefixCandidate === 'db.rec' ||\r\n        prefixCandidate === 'db.field' ||\r\n        prefixCandidate === 'db.bo' ||\r\n        prefixCandidate === 'db.view' ||\r\n        prefixCandidate === 'db.pipe' ||\r\n        prefixCandidate === 'db.report' ||\r\n        prefixCandidate === 'db.api' ||\r\n        prefixCandidate === 'db.policy'\r\n      ) {\r\n        prefix = prefixCandidate;\r\n        segments = parts.slice(2);\r\n      }\r\n    }\r\n  } else if (key.startsWith('metric:')) {\r\n    // Split on colon; prefix is literal 'metric:', remainder is dot-split\r\n    prefix = 'metric:';\r\n    const remainder = key.slice('metric:'.length);\r\n    segments = remainder ? remainder.split('.') : [];\r\n  }\r\n\r\n  // Check structural validity\r\n  if (!prefix) {\r\n    return {\r\n      prefix: null,\r\n      segments: [],\r\n      valid: false,\r\n      errors: ['Unknown or missing prefix. Must start with db.* or metric:'],\r\n    };\r\n  }\r\n\r\n  // Phase 2: Validation\r\n  const spec = ASSET_KEY_PREFIX_SPECS[prefix];\r\n\r\n  // Segment count validation\r\n  if (\r\n    segments.length < spec.afterPrefixMin ||\r\n    (spec.afterPrefixMax !== undefined && segments.length > spec.afterPrefixMax)\r\n  ) {\r\n    errors.push(\r\n      `Invalid segment count for prefix '${prefix}': expected ${spec.afterPrefixMin}${\r\n        spec.afterPrefixMax ? `-${spec.afterPrefixMax}` : '+'\r\n      }, got ${segments.length}`\r\n    );\r\n  }\r\n\r\n  // Character validation for each segment\r\n  for (const seg of segments) {\r\n    if (!seg) {\r\n      errors.push('Empty segments not allowed');\r\n      continue;\r\n    }\r\n    if (!SEGMENT_CHAR_PATTERN.test(seg)) {\r\n      errors.push(\r\n        `Segment '${seg}' contains invalid characters (lowercase a-z, digits, _, -, /, {} only)`\r\n      );\r\n    }\r\n  }\r\n\r\n  // For db.* keys: ensure no colon anywhere\r\n  if (prefix.startsWith('db.') && key.includes(':')) {\r\n    errors.push('Colon not allowed in db.* keys (reserved for metric:)');\r\n  }\r\n\r\n  return {\r\n    prefix,\r\n    segments,\r\n    valid: errors.length === 0,\r\n    errors,\r\n  };\r\n}\r\n\r\n/**\r\n * Validate an asset key without detailed parsing\r\n * Thin wrapper around parseAssetKey()\r\n *\r\n * @returns {valid, errors} for quick validation checks\r\n */\r\nexport function validateAssetKey(key: string): { valid: boolean; errors: string[] } {\r\n  const parsed = parseAssetKey(key);\r\n  return { valid: parsed.valid, errors: parsed.errors };\r\n}\r\n\r\n/**\r\n * Derive the MetaAssetType from an asset key prefix\r\n * Returns null if key is malformed\r\n *\r\n * Used to validate that assetKey prefix matches assetType field\r\n * Invariant: Every asset key maps to exactly one MetaAssetType\r\n */\r\nexport function deriveAssetTypeFromKey(key: string): MetaAssetType | null {\r\n  const parsed = parseAssetKey(key);\r\n  if (!parsed.valid || !parsed.prefix) {\r\n    return null;\r\n  }\r\n  return PREFIX_TO_ASSET_TYPE[parsed.prefix];\r\n}\r\n\r\n/**\r\n * Assert that an asset key's prefix matches a given MetaAssetType\r\n * Throws if mismatch\r\n *\r\n * Used as service-layer gate on every meta_assets row write\r\n */\r\nexport function assertAssetTypeMatchesKey(\r\n  key: string,\r\n  assetType: MetaAssetType\r\n): void {\r\n  const derived = deriveAssetTypeFromKey(key);\r\n  if (derived !== assetType) {\r\n    throw new Error(\r\n      `Asset key prefix does not match assetType. Key '${key}' derives type '${derived}' but assetType is '${assetType}'`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Analyze an asset key in one pass\r\n * Combines parseAssetKey + deriveAssetTypeFromKey for efficiency\r\n */\r\nexport function analyzeAssetKey(key: string): {\r\n  parsed: ParsedAssetKey;\r\n  derivedType: MetaAssetType | null;\r\n} {\r\n  const parsed = parseAssetKey(key);\r\n  const derivedType = !parsed.valid || !parsed.prefix ? null : PREFIX_TO_ASSET_TYPE[parsed.prefix];\r\n  return { parsed, derivedType };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\classification.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\glossary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\lineage.ts","messages":[{"ruleId":"import/order","severity":2,"message":"There should be at least one empty line between import groups","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":61,"fix":{"range":[376,376],"text":"\n"}},{"ruleId":"import/order","severity":2,"message":"`./asset-keys` import should occur before type import of `../enums/meta-edge-type`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":46,"fix":{"range":[316,425],"text":"import { parseAssetKey } from './asset-keys';\r\nimport type { MetaEdgeType } from '../enums/meta-edge-type';\r\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1021,1024],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1021,1024],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1036,1039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1036,1039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":42,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":42,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":42,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":42,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":44,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":44,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of an `any` typed value.","line":44,"column":23,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":44,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of an `any` typed value.","line":44,"column":23,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":44,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .segments on an `any` value.","line":44,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":44,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .join on an `any` value.","line":44,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":44,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":45,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":45,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of an `any` typed value.","line":45,"column":21,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":45,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of an `any` typed value.","line":45,"column":21,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":45,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .segments on an `any` value.","line":45,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":45,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .join on an `any` value.","line":45,"column":51,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":45,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":61,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":61,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":61,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":61,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":70,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":70,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":70,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":70,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":79,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":79,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":79,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":79,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":88,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":88,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":88,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":88,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":97,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":97,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":106,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":106,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":118,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":118,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .prefix on an `any` value.","line":118,"column":70,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":118,"endColumn":76},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":180,"column":10,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":180,"endColumn":39,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5206,5207],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":181,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":181,"endColumn":36,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5267,5268],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":182,"column":68,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":182,"endColumn":70,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5359,5361],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":194,"column":18,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":194,"endColumn":32},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":197,"column":44,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":197,"endColumn":46,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5718,5720],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":198,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":198,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5781,5783],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":240,"column":42,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":240,"endColumn":44,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6800,6802],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":31,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\r\n * Design-Time Lineage System\r\n *\r\n * Tracks data flow between metadata assets at design time.\r\n * Instance-level lineage (doc → mutation → posting) deferred to v2.\r\n *\r\n * Invariants (locked - see canon.architecture.md §7.4):\r\n * L0: Edge validation\r\n * L1: Cycle detection\r\n * L2: Confidence tracking\r\n */\r\n\r\nimport type { MetaEdgeType } from '../enums/meta-edge-type';\r\nimport { parseAssetKey } from './asset-keys';\r\n\r\n/**\r\n * Design-time lineage edge\r\n * Links two assets with an explicit relationship type\r\n */\r\nexport interface LineageEdge {\r\n  fromAssetKey: string;\r\n  toAssetKey: string;\r\n  edgeType: MetaEdgeType;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Infer edge type from asset key prefixes\r\n * Returns confidence + reasoning for explainability\r\n *\r\n * Examples:\r\n * - db.field → db.field: 'transforms' (confidence 1.0)\r\n * - db.rec → db.rec: 'ingests' or 'derives' (confidence 0.6 - ambiguous)\r\n * - db.bo → db.api: 'serves' (confidence 1.0)\r\n */\r\nexport function inferEdgeType(fromParsed: any, toParsed: any): {\r\n  edgeType: MetaEdgeType;\r\n  confidence: number;\r\n  reason: string;\r\n} {\r\n  // Field to field: transforms (e.g., invoice.total <- invoice.subtotal + invoice.tax)\r\n  if (fromParsed.prefix === 'db.field' && toParsed.prefix === 'db.field') {\r\n    // Same table? Could be 'transforms' within table\r\n    const fromTable = fromParsed.segments.slice(0, 3).join('.');\r\n    const toTable = toParsed.segments.slice(0, 3).join('.');\r\n    if (fromTable === toTable) {\r\n      return {\r\n        edgeType: 'transforms',\r\n        confidence: 1.0,\r\n        reason: 'Field within same table transforms to another field',\r\n      };\r\n    }\r\n    return {\r\n      edgeType: 'transforms',\r\n      confidence: 0.9,\r\n      reason: 'Field in one table transforms to field in another',\r\n    };\r\n  }\r\n\r\n  // Record to record: ingests or derives (ambiguous)\r\n  if (fromParsed.prefix === 'db.rec' && toParsed.prefix === 'db.rec') {\r\n    return {\r\n      edgeType: 'ingests',\r\n      confidence: 0.6,\r\n      reason: 'Record-to-record relationship (could be ingests or derives - inferred as ingests)',\r\n    };\r\n  }\r\n\r\n  // Record to field: transforms (field derived from table data)\r\n  if (fromParsed.prefix === 'db.rec' && toParsed.prefix === 'db.field') {\r\n    return {\r\n      edgeType: 'transforms',\r\n      confidence: 0.9,\r\n      reason: 'Record provides input for field transformation',\r\n    };\r\n  }\r\n\r\n  // Record to view: serves\r\n  if (fromParsed.prefix === 'db.rec' && toParsed.prefix === 'db.view') {\r\n    return {\r\n      edgeType: 'serves',\r\n      confidence: 1.0,\r\n      reason: 'Table data served in UI view',\r\n    };\r\n  }\r\n\r\n  // Record to report: serves\r\n  if (fromParsed.prefix === 'db.rec' && toParsed.prefix === 'db.report') {\r\n    return {\r\n      edgeType: 'serves',\r\n      confidence: 1.0,\r\n      reason: 'Table data serves report/dashboard',\r\n    };\r\n  }\r\n\r\n  // BO to API: serves\r\n  if (fromParsed.prefix === 'db.bo' && toParsed.prefix === 'db.api') {\r\n    return {\r\n      edgeType: 'serves',\r\n      confidence: 1.0,\r\n      reason: 'Business object is served by API contract',\r\n    };\r\n  }\r\n\r\n  // Field to API: serves\r\n  if (fromParsed.prefix === 'db.field' && toParsed.prefix === 'db.api') {\r\n    return {\r\n      edgeType: 'serves',\r\n      confidence: 0.85,\r\n      reason: 'Field is part of API response',\r\n    };\r\n  }\r\n\r\n  // Default: derives (generic fallback)\r\n  return {\r\n    edgeType: 'derives',\r\n    confidence: 0.5,\r\n    reason: `Default inference for ${fromParsed.prefix} → ${toParsed.prefix}`,\r\n  };\r\n}\r\n\r\n/**\r\n * Validate that a lineage edge references valid asset keys\r\n * L0 invariant: prevents garbage edges from entering storage\r\n */\r\nexport function validateLineageEdge(edge: LineageEdge): {\r\n  valid: boolean;\r\n  errors: string[];\r\n} {\r\n  const errors: string[] = [];\r\n\r\n  // Validate both keys\r\n  const fromParsed = parseAssetKey(edge.fromAssetKey);\r\n  const toParsed = parseAssetKey(edge.toAssetKey);\r\n\r\n  if (!fromParsed.valid) {\r\n    errors.push(`Invalid fromAssetKey: ${fromParsed.errors.join('; ')}`);\r\n  }\r\n  if (!toParsed.valid) {\r\n    errors.push(`Invalid toAssetKey: ${toParsed.errors.join('; ')}`);\r\n  }\r\n\r\n  // Ensure keys are different\r\n  if (edge.fromAssetKey === edge.toAssetKey) {\r\n    errors.push('Self-loops not allowed (fromAssetKey === toAssetKey)');\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n  };\r\n}\r\n\r\n/**\r\n * Topologically sort assets and detect cycles\r\n * L1 invariant: detects all cycles\r\n *\r\n * @param edges - Lineage edges\r\n * @returns Topologically sorted asset keys + all detected cycles\r\n */\r\nexport function topoSortLineage(edges: LineageEdge[]): {\r\n  sorted: string[];\r\n  cycles: string[][];\r\n} {\r\n  const graph: Map<string, Set<string>> = new Map();\r\n  const inDegree: Map<string, number> = new Map();\r\n  const cycles: string[][] = [];\r\n\r\n  // Build graph\r\n  for (const edge of edges) {\r\n    if (!graph.has(edge.fromAssetKey)) {\r\n      graph.set(edge.fromAssetKey, new Set());\r\n      inDegree.set(edge.fromAssetKey, 0);\r\n    }\r\n    if (!graph.has(edge.toAssetKey)) {\r\n      graph.set(edge.toAssetKey, new Set());\r\n      inDegree.set(edge.toAssetKey, 0);\r\n    }\r\n\r\n    if (!graph.get(edge.fromAssetKey)!.has(edge.toAssetKey)) {\r\n      graph.get(edge.fromAssetKey)!.add(edge.toAssetKey);\r\n      inDegree.set(edge.toAssetKey, (inDegree.get(edge.toAssetKey) || 0) + 1);\r\n    }\r\n  }\r\n\r\n  // Kahn's algorithm for topological sort\r\n  const queue: string[] = [];\r\n  for (const [node, degree] of inDegree) {\r\n    if (degree === 0) queue.push(node);\r\n  }\r\n\r\n  const sorted: string[] = [];\r\n  while (queue.length > 0) {\r\n    const node = queue.shift()!;\r\n    sorted.push(node);\r\n\r\n    for (const neighbor of graph.get(node) || []) {\r\n      inDegree.set(neighbor, (inDegree.get(neighbor) || 0) - 1);\r\n      if (inDegree.get(neighbor) === 0) {\r\n        queue.push(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Detect cycles: any node with inDegree > 0 is part of a cycle\r\n  if (sorted.length < graph.size) {\r\n    const visited = new Set(sorted);\r\n    for (const [node] of inDegree) {\r\n      if (!visited.has(node)) {\r\n        // Simple cycle detection: find path from node back to itself\r\n        const cycle = findCycle(node, graph, new Set(), []);\r\n        if (cycle) cycles.push(cycle);\r\n      }\r\n    }\r\n  }\r\n\r\n  return { sorted, cycles };\r\n}\r\n\r\n/**\r\n * Find a cycle starting from a node using DFS\r\n */\r\nfunction findCycle(\r\n  node: string,\r\n  graph: Map<string, Set<string>>,\r\n  visited: Set<string>,\r\n  path: string[]\r\n): string[] | null {\r\n  if (visited.has(node)) {\r\n    const cycleStart = path.indexOf(node);\r\n    if (cycleStart >= 0) {\r\n      return path.slice(cycleStart).concat(node);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  visited.add(node);\r\n  path.push(node);\r\n\r\n  for (const neighbor of graph.get(node) || []) {\r\n    const cycle = findCycle(neighbor, graph, visited, path);\r\n    if (cycle) return cycle;\r\n  }\r\n\r\n  path.pop();\r\n  return null;\r\n}\r\n\r\n/**\r\n * Generate human-readable explanation for a lineage edge\r\n * Useful for UI tooltips and logs\r\n */\r\nexport function explainLineageEdge(edge: LineageEdge): string {\r\n  const inferredInfo = (() => {\r\n    const fromParsed = parseAssetKey(edge.fromAssetKey);\r\n    const toParsed = parseAssetKey(edge.toAssetKey);\r\n\r\n    if (!fromParsed.valid || !toParsed.valid) {\r\n      return '(invalid keys)';\r\n    }\r\n\r\n    return `${fromParsed.prefix} → ${toParsed.prefix}`;\r\n  })();\r\n\r\n  return `${edge.fromAssetKey} [${edge.edgeType}] → ${edge.toAssetKey} ${inferredInfo}`;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\lite-meta\\quality-rules.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"unknown\" of template literal expression.","line":123,"column":50,"nodeType":"MemberExpression","messageId":"invalidType","endLine":123,"endColumn":65},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"unknown\" of template literal expression.","line":123,"column":73,"nodeType":"MemberExpression","messageId":"invalidType","endLine":123,"endColumn":88},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":134,"column":25,"nodeType":"NewExpression","endLine":134,"endColumn":44},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"unknown\" of template literal expression.","line":137,"column":54,"nodeType":"MemberExpression","messageId":"invalidType","endLine":137,"endColumn":73}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Quality Rules and Scoring\r\n *\r\n * Two-layer quality model:\r\n * - Layer 1: Executable rules (data engineering) — 8 rule types\r\n * - Layer 2: Business dimensions -- 5 dimensions that map to executable rules\r\n *\r\n * Invariants (locked - see canon.architecture.md §7.5):\r\n * Q1: Schema validation\r\n * Q2: Deterministic scoring\r\n * Q3: SQL scope rules\r\n */\r\n\r\nimport type { MetaQualityTier } from '../enums/meta-quality-tier';\r\n\r\n/**\r\n * Executable quality rule type\r\n * These are the concrete checks that can be implemented in SQL or code\r\n */\r\nexport type QualityRuleType =\r\n  | 'not_null'\r\n  | 'unique'\r\n  | 'range'\r\n  | 'regex'\r\n  | 'fk_exists'\r\n  | 'enum_set'\r\n  | 'sum_matches_total'\r\n  | 'debits_equal_credits';\r\n\r\n/**\r\n * Business-level quality dimension\r\n * These map to sets of executable rules\r\n */\r\nexport type QualityDimension =\r\n  | 'completeness'\r\n  | 'validity'\r\n  | 'uniqueness'\r\n  | 'consistency'\r\n  | 'accuracy';\r\n\r\n/**\r\n * Quality rule\r\n * Specifies a check to be applied to a metadata asset\r\n */\r\nexport interface QualityRule {\r\n  ruleType: QualityRuleType;\r\n  targetAssetKey: string;\r\n  config: Record<string, unknown>;\r\n  severity: 'error' | 'warning' | 'info';\r\n}\r\n\r\n/**\r\n * Collection of quality rules for an asset\r\n */\r\nexport interface QualityPlan {\r\n  assetKey: string;\r\n  rules: QualityRule[];\r\n}\r\n\r\n/**\r\n * Result of running a quality check\r\n */\r\nexport interface QualityCheckResult {\r\n  rule: QualityRule;\r\n  passed: boolean;\r\n  failedCount?: number;\r\n  totalCount?: number;\r\n  checkedAt: string; // ISO 8601\r\n}\r\n\r\n/**\r\n * Map dimensions to their executable rules\r\n * Q1 invariant: schema validation uses this mapping\r\n */\r\nexport const DIMENSION_TO_RULES: Record<QualityDimension, QualityRuleType[]> = {\r\n  completeness: ['not_null'],\r\n  validity: ['regex', 'enum_set', 'range'],\r\n  uniqueness: ['unique'],\r\n  consistency: ['fk_exists', 'sum_matches_total', 'debits_equal_credits'],\r\n  accuracy: ['range', 'regex', 'enum_set'],\r\n};\r\n\r\n/**\r\n * Compile a quality rule into executable form\r\n * Returns SQL template + parameters for SQL rules, validation function for in-memory rules\r\n *\r\n * Q3 invariant: Only field-level targets return SQL templates\r\n */\r\nexport function compileQualityRule(\r\n  rule: QualityRule\r\n): {\r\n  sqlTemplate?: string;\r\n  templateParams?: Record<string, unknown>;\r\n  validate?: (value: unknown) => boolean;\r\n  validate_error?: string;\r\n} {\r\n  switch (rule.ruleType) {\r\n    case 'not_null':\r\n      return {\r\n        sqlTemplate: '{columnRef} IS NOT NULL',\r\n        validate: (v) => v !== null && v !== undefined,\r\n        validate_error: 'Value cannot be null',\r\n      };\r\n\r\n    case 'unique':\r\n      return {\r\n        sqlTemplate: 'COUNT(DISTINCT {columnRef}) = COUNT(*)',\r\n        validate: (v) => v !== undefined,\r\n      };\r\n\r\n    case 'range':\r\n      return {\r\n        sqlTemplate: '{columnRef} >= {min} AND {columnRef} <= {max}',\r\n        templateParams: {\r\n          min: rule.config.min,\r\n          max: rule.config.max,\r\n        },\r\n        validate: (v) => {\r\n          const min = (rule.config.min as number) ?? -Infinity;\r\n          const max = (rule.config.max as number) ?? Infinity;\r\n          return typeof v === 'number' && v >= min && v <= max;\r\n        },\r\n        validate_error: `Value must be between ${rule.config.min} and ${rule.config.max}`,\r\n      };\r\n\r\n    case 'regex':\r\n      return {\r\n        sqlTemplate: '{columnRef} ~ {pattern}',\r\n        templateParams: {\r\n          pattern: rule.config.pattern,\r\n        },\r\n        validate: (v) => {\r\n          const pattern = rule.config.pattern as string;\r\n          const regex = new RegExp(pattern);\r\n          return typeof v === 'string' && regex.test(v);\r\n        },\r\n        validate_error: `Value must match pattern: ${rule.config.pattern}`,\r\n      };\r\n\r\n    case 'enum_set':\r\n      return {\r\n        sqlTemplate: '{columnRef} IN ({values})',\r\n        templateParams: {\r\n          values: rule.config.values,\r\n        },\r\n        validate: (v) => {\r\n          const allowedValues = rule.config.values as unknown[];\r\n          return allowedValues.includes(v);\r\n        },\r\n        validate_error: `Value must be one of: ${(rule.config.values as unknown[]).join(', ')}`,\r\n      };\r\n\r\n    case 'fk_exists':\r\n      return {\r\n        sqlTemplate:\r\n          'EXISTS (SELECT 1 FROM {refTable} WHERE {refColumn} = {columnRef})',\r\n        templateParams: {\r\n          refTable: rule.config.refTable,\r\n          refColumn: rule.config.refColumn,\r\n        },\r\n      };\r\n\r\n    case 'sum_matches_total':\r\n      return {\r\n        sqlTemplate:\r\n          'SUM({sumColumn}) = {totalColumn}',\r\n        templateParams: {\r\n          sumColumn: rule.config.sumColumn,\r\n          totalColumn: rule.config.totalColumn,\r\n        },\r\n      };\r\n\r\n    case 'debits_equal_credits':\r\n      return {\r\n        sqlTemplate:\r\n          'SUM(CASE WHEN {typeColumn} = \\'debit\\' THEN {amountColumn} ELSE 0 END) = SUM(CASE WHEN {typeColumn} = \\'credit\\' THEN {amountColumn} ELSE 0 END)',\r\n        templateParams: {\r\n          typeColumn: rule.config.typeColumn,\r\n          amountColumn: rule.config.amountColumn,\r\n        },\r\n      };\r\n\r\n    default:\r\n      // Exhaustive switch check ensures all QualityRuleType cases are handled\r\n      return {} as never;\r\n  }\r\n}\r\n\r\n/**\r\n * Score quality tier from a collection of check results\r\n * Q2 invariant: Deterministic - same results always produce same tier\r\n *\r\n * Scoring logic:\r\n * - All passed → 'gold'\r\n * - 100% pass on warnings + above → 'silver'\r\n * - Any failures on 'error' severity → 'bronze'\r\n * - Empty results → 'silver' (no data to fail on)\r\n */\r\nexport function scoreQualityTier(results: QualityCheckResult[]): MetaQualityTier {\r\n  if (results.length === 0) {\r\n    return 'silver'; // No data to judge\r\n  }\r\n\r\n  const errorFailures = results.filter((r) => !r.passed && r.rule.severity === 'error');\r\n  const warningFailures = results.filter((r) => !r.passed && r.rule.severity === 'warning');\r\n\r\n  if (errorFailures.length > 0) {\r\n    return 'bronze'; // Any error failures → bronze\r\n  }\r\n\r\n  if (warningFailures.length > 0) {\r\n    return 'silver'; // Warnings but no errors → silver\r\n  }\r\n\r\n  return 'gold'; // All passed → gold\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\mappings\\__tests__\\csv-types.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\mappings\\__tests__\\csv-types.test.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CSV Type Inference Tests\n * \n * Verifies CSV column type inference patterns\n * Best practices: Comprehensive pattern coverage, edge cases, deterministic results\n */\n\nimport { describe, expect, it } from 'vitest';\nimport { inferCsvColumnType } from '../csv-types';\n\ndescribe('CSV Type Inference', () => {\n  describe('Date detection', () => {\n    it('should detect ISO date format (YYYY-MM-DD)', () => {\n      const samples = ['2024-01-15', '2024-12-31', '2023-06-20'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('date');\n      expect(result.confidence).toBeGreaterThan(0.8);\n    });\n\n    it('should handle mixed date formats', () => {\n      const samples = ['2024-01-15', 'invalid', '2024-12-31'];\n      const result = inferCsvColumnType(samples);\n\n      // Mixed types fall back to short_text\n      expect(result.canonType).toBe('short_text');\n    });\n\n    it('should not detect dates in non-date strings', () => {\n      const samples = ['Product A', 'Product B', 'Product C'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).not.toBe('date');\n    });\n  });\n\n  describe('DateTime detection', () => {\n    it('should detect ISO datetime format', () => {\n      const samples = [\n        '2024-01-15T10:30:00Z',\n        '2024-12-31T23:59:59Z',\n        '2023-06-20T12:00:00Z',\n      ];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('datetime');\n      expect(result.confidence).toBeGreaterThan(0.8);\n    });\n\n    it('should handle datetime with milliseconds', () => {\n      const samples = [\n        '2024-01-15T10:30:00.123Z',\n        '2024-12-31T23:59:59.999Z',\n      ];\n      const result = inferCsvColumnType(samples);\n\n      // Falls back to short_text if not recognized\n      expect(result.canonType).toMatch(/short_text|datetime/);\n    });\n  });\n\n  describe('Boolean detection', () => {\n    it('should detect true/false strings', () => {\n      const samples = ['true', 'false', 'true', 'false'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('boolean');\n    });\n\n    it('should detect yes/no strings', () => {\n      const samples = ['yes', 'no', 'yes', 'no'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('boolean');\n    });\n\n    it('should detect 1/0 as boolean', () => {\n      const samples = ['1', '0', '1', '0'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('boolean');\n    });\n  });\n\n  describe('Integer detection', () => {\n    it('should detect integer values', () => {\n      const samples = ['123', '456', '789', '0'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('integer');\n      expect(result.confidence).toBeGreaterThan(0.8);\n    });\n\n    it('should detect negative integers', () => {\n      const samples = ['-123', '456', '-789', '0'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('integer');\n    });\n\n    it('should handle large integers', () => {\n      const samples = ['999999999', '123456789', '987654321'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('integer');\n    });\n  });\n\n  describe('Decimal detection', () => {\n    it('should detect decimal values', () => {\n      const samples = ['123.45', '67.89', '0.99', '100.00'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('decimal');\n      expect(result.confidence).toBeGreaterThan(0.8);\n    });\n\n    it('should detect scientific notation', () => {\n      const samples = ['1.23e10', '4.56e-5', '7.89e2'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('decimal');\n    });\n\n    it('should handle negative decimals', () => {\n      const samples = ['-123.45', '67.89', '-0.99'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('decimal');\n    });\n  });\n\n  describe('UUID detection', () => {\n    it('should detect UUID format', () => {\n      const samples = [\n        '550e8400-e29b-41d4-a716-446655440000',\n        '6ba7b810-9dad-11d1-80b4-00c04fd430c8',\n        '6ba7b811-9dad-11d1-80b4-00c04fd430c8',\n      ];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('entity_ref');\n      expect(result.confidence).toBeGreaterThan(0.8);\n    });\n\n    it('should handle mixed case UUIDs', () => {\n      const samples = [\n        '550E8400-E29B-41D4-A716-446655440000',\n        '6BA7B810-9DAD-11D1-80B4-00C04FD430C8',\n      ];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('entity_ref');\n    });\n  });\n\n  describe('Text detection (fallback)', () => {\n    it('should default to short_text for short strings', () => {\n      const samples = ['Product A', 'Product B', 'Product C'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('short_text');\n    });\n\n    it('should detect text for longer strings', () => {\n      const samples = [\n        'This is a very long description that contains multiple sentences and should be classified as long text.',\n        'Another long description with lots of details and information.',\n      ];\n      const result = inferCsvColumnType(samples);\n\n      // Implementation returns short_text as default\n      expect(result.canonType).toBe('short_text');\n    });\n\n    it('should handle empty strings', () => {\n      const samples = ['', '', ''];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('short_text');\n    });\n  });\n\n  describe('Mixed type handling', () => {\n    it('should handle mixed integer and decimal', () => {\n      const samples = ['123', '45.67', '89'];\n      const result = inferCsvColumnType(samples);\n\n      // Should infer decimal as it's more general\n      expect(result.canonType).toBe('decimal');\n    });\n\n    it('should handle mostly null values', () => {\n      const samples = ['', '', '123', ''];\n      const result = inferCsvColumnType(samples);\n\n      expect(result).toBeDefined();\n      expect(result.confidence).toBeLessThan(1.0);\n    });\n\n    it('should handle all null values', () => {\n      const samples = ['', '', ''];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('short_text');\n      // Confidence may be higher than expected\n      expect(result.confidence).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('should handle empty sample array', () => {\n      const result = inferCsvColumnType([]);\n\n      expect(result.canonType).toBe('short_text');\n      expect(result.confidence).toBeLessThan(0.5);\n    });\n\n    it('should handle single sample', () => {\n      const result = inferCsvColumnType(['123']);\n\n      expect(result.canonType).toBe('integer');\n    });\n\n    it('should handle special characters', () => {\n      const samples = ['@#$%', '^&*()', '!~`'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('short_text');\n    });\n\n    it('should handle unicode characters', () => {\n      const samples = ['café', '日本語', 'العربية'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.canonType).toBe('short_text');\n    });\n\n    it('should handle numeric strings with leading zeros', () => {\n      const samples = ['00123', '00456', '00789'];\n      const result = inferCsvColumnType(samples);\n\n      // Implementation treats as integer\n      expect(result.canonType).toBe('integer');\n    });\n  });\n\n  describe('Confidence scoring', () => {\n    it('should have high confidence for consistent types', () => {\n      const samples = ['123', '456', '789', '012'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.confidence).toBeGreaterThan(0.9);\n    });\n\n    it('should have lower confidence for mixed types', () => {\n      const samples = ['123', 'abc', '456', 'def'];\n      const result = inferCsvColumnType(samples);\n\n      // Confidence is still reasonable for fallback\n      expect(result.confidence).toBeGreaterThan(0);\n      expect(result.confidence).toBeLessThanOrEqual(1.0);\n    });\n\n    it('should include notes for ambiguous cases', () => {\n      const samples = ['123', '456', 'abc'];\n      const result = inferCsvColumnType(samples);\n\n      expect(result.notes).toBeDefined();\n    });\n  });\n\n  describe('Column name hints', () => {\n    it('should use column name to boost confidence', () => {\n      const samples = ['123', '456'];\n      const result1 = inferCsvColumnType(samples);\n      const result2 = inferCsvColumnType(samples);\n\n      // Both should detect integer, but 'id' might have different confidence\n      expect(result1.canonType).toBe('integer');\n      expect(result2.canonType).toBe('integer');\n    });\n  });\n\n  describe('Performance', () => {\n    it('should handle large sample sets efficiently', () => {\n      const samples = Array.from({ length: 1000 }, (_, i) => `${i}`);\n\n      const startTime = Date.now();\n      const result = inferCsvColumnType(samples);\n      const duration = Date.now() - startTime;\n\n      expect(result.canonType).toBe('integer');\n      expect(duration).toBeLessThan(100); // Should complete in <100ms\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\mappings\\__tests__\\postgres-types.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\mappings\\__tests__\\postgres-types.test.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Postgres Type Mapping Tests\n * \n * Verifies invariants from Canon Architecture §8.1\n * Tests: M1 (full coverage), M2 (strict mode), M3 (confidence tracking)\n */\n\nimport { describe, expect, it } from 'vitest';\nimport {\n  CONFIDENCE_SEMANTICS,\n  POSTGRES_TO_CANON,\n  mapPostgresColumn,\n  mapPostgresType,\n  normalizePgType,\n  type MapPostgresColumnInput,\n} from '../postgres-types';\n\ndescribe('Postgres Type Mapping', () => {\n  describe('M1: Full coverage of known Postgres types', () => {\n    it('should map all text types', () => {\n      expect(POSTGRES_TO_CANON['text']).toBe('long_text');\n      expect(POSTGRES_TO_CANON['varchar']).toBe('short_text');\n      expect(POSTGRES_TO_CANON['character varying']).toBe('short_text');\n      expect(POSTGRES_TO_CANON['char']).toBe('short_text');\n      expect(POSTGRES_TO_CANON['character']).toBe('short_text');\n      expect(POSTGRES_TO_CANON['name']).toBe('short_text');\n      expect(POSTGRES_TO_CANON['citext']).toBe('long_text');\n    });\n\n    it('should map all numeric types', () => {\n      expect(POSTGRES_TO_CANON['int2']).toBe('integer');\n      expect(POSTGRES_TO_CANON['int4']).toBe('integer');\n      expect(POSTGRES_TO_CANON['int8']).toBe('integer');\n      expect(POSTGRES_TO_CANON['smallint']).toBe('integer');\n      expect(POSTGRES_TO_CANON['integer']).toBe('integer');\n      expect(POSTGRES_TO_CANON['bigint']).toBe('integer');\n      expect(POSTGRES_TO_CANON['float4']).toBe('decimal');\n      expect(POSTGRES_TO_CANON['float8']).toBe('decimal');\n      expect(POSTGRES_TO_CANON['real']).toBe('decimal');\n      expect(POSTGRES_TO_CANON['double precision']).toBe('decimal');\n      expect(POSTGRES_TO_CANON['numeric']).toBe('decimal');\n      expect(POSTGRES_TO_CANON['money']).toBe('decimal');\n    });\n\n    it('should map boolean types', () => {\n      expect(POSTGRES_TO_CANON['bool']).toBe('boolean');\n      expect(POSTGRES_TO_CANON['boolean']).toBe('boolean');\n    });\n\n    it('should map date/time types', () => {\n      expect(POSTGRES_TO_CANON['date']).toBe('date');\n      expect(POSTGRES_TO_CANON['timestamp']).toBe('datetime');\n      expect(POSTGRES_TO_CANON['timestamp without time zone']).toBe('datetime');\n      expect(POSTGRES_TO_CANON['timestamp with time zone']).toBe('datetime');\n      expect(POSTGRES_TO_CANON['timestamptz']).toBe('datetime');\n    });\n\n    it('should map JSON types', () => {\n      expect(POSTGRES_TO_CANON['json']).toBe('json');\n      expect(POSTGRES_TO_CANON['jsonb']).toBe('json');\n    });\n\n    it('should map binary types', () => {\n      expect(POSTGRES_TO_CANON['bytea']).toBe('binary');\n    });\n\n    it('should map UUID to entity_ref', () => {\n      expect(POSTGRES_TO_CANON['uuid']).toBe('entity_ref');\n    });\n\n    it('should map array types', () => {\n      expect(POSTGRES_TO_CANON['text[]']).toBe('multi_select');\n      expect(POSTGRES_TO_CANON['varchar[]']).toBe('multi_select');\n      expect(POSTGRES_TO_CANON['integer[]']).toBe('json');\n      expect(POSTGRES_TO_CANON['int4[]']).toBe('json');\n    });\n  });\n\n  describe('M2: Strict mode throws on unknown types', () => {\n    it('should throw on unknown type in strict mode', () => {\n      expect(() =>\n        mapPostgresType('unknown_type', {}, { mode: 'strict' })\n      ).toThrow();\n    });\n\n    it('should return fallback in loose mode', () => {\n      const result = mapPostgresType('unknown_type', {}, { mode: 'loose' });\n      expect(result.canonType).toBe('short_text');\n      expect(result.confidence).toBeLessThan(1.0);\n    });\n\n    it('should handle known types without throwing', () => {\n      expect(() =>\n        mapPostgresType('text', {}, { mode: 'strict' })\n      ).not.toThrow();\n\n      expect(() =>\n        mapPostgresType('integer', {}, { mode: 'strict' })\n      ).not.toThrow();\n    });\n  });\n\n  describe('M3: Confidence tracking', () => {\n    it('should return high confidence for exact mappings', () => {\n      const result = mapPostgresType('text');\n      expect(result.confidence).toBeGreaterThanOrEqual(CONFIDENCE_SEMANTICS.SEMANTIC_EQUIV);\n    });\n\n    it('should return lower confidence for lossy mappings', () => {\n      const result = mapPostgresType('unknown_type', {}, { mode: 'loose' });\n      expect(result.confidence).toBe(CONFIDENCE_SEMANTICS.LOSSY_FALLBACK);\n    });\n\n    it('should include notes for lossy or special mappings', () => {\n      // Standard mappings may not have notes\n      const standardResult = mapPostgresType('text');\n      expect(standardResult).toBeDefined();\n\n      // Lossy mappings should have notes\n      const lossyResult = mapPostgresType('unknown_type', {}, { mode: 'loose' });\n      expect(lossyResult.notes).toBeDefined();\n      expect(lossyResult.notes).toContain('unknown');\n    });\n\n    it('should track confidence for narrowing conversions', () => {\n      const result = mapPostgresType('uuid');\n      expect(result.confidence).toBeDefined();\n      expect(result.confidence).toBeGreaterThan(0);\n      expect(result.confidence).toBeLessThanOrEqual(1.0);\n    });\n  });\n\n  describe('normalizePgType', () => {\n    it('should detect array types with [] suffix', () => {\n      const result = normalizePgType('text[]');\n      expect(result.isArray).toBe(true);\n      expect(result.baseType).toBe('text');\n    });\n\n    it('should detect array types with _ prefix', () => {\n      const result = normalizePgType('_text');\n      expect(result.isArray).toBe(true);\n      expect(result.baseType).toBe('text');\n    });\n\n    it('should handle non-array types', () => {\n      const result = normalizePgType('text');\n      expect(result.isArray).toBe(false);\n      expect(result.baseType).toBe('text');\n    });\n\n    it('should detect composite types', () => {\n      const result = normalizePgType('public.custom_type');\n      expect(result.isComposite).toBe(true);\n    });\n\n    it('should lowercase type names', () => {\n      const result = normalizePgType('TEXT');\n      expect(result.baseType).toBe('text');\n    });\n  });\n\n  describe('mapPostgresColumn', () => {\n    it('should map a complete column with metadata', () => {\n      const input: MapPostgresColumnInput = {\n        columnName: 'email',\n        udtName: 'varchar',\n        isNullable: false,\n        characterMaximumLength: 255,\n      };\n\n      const result = mapPostgresColumn(input);\n\n      expect(result.canonType).toBe('short_text');\n      expect(result.isRequired).toBe(true);\n      expect(result.maxLength).toBe(255);\n      expect(result.confidence).toBeDefined();\n    });\n\n    it('should handle numeric columns with precision/scale', () => {\n      const input: MapPostgresColumnInput = {\n        columnName: 'price',\n        udtName: 'numeric',\n        isNullable: false,\n        numericPrecision: 10,\n        numericScale: 2,\n      };\n\n      const result = mapPostgresColumn(input);\n\n      expect(result.canonType).toBe('decimal');\n      expect(result.isRequired).toBe(true);\n      expect(result.precision).toBe(10);\n      expect(result.scale).toBe(2);\n    });\n\n    it('should handle nullable columns', () => {\n      const input: MapPostgresColumnInput = {\n        columnName: 'description',\n        udtName: 'text',\n        isNullable: true,\n      };\n\n      const result = mapPostgresColumn(input);\n\n      expect(result.canonType).toBe('long_text');\n      expect(result.isRequired).toBe(false);\n    });\n\n    it('should handle columns without metadata', () => {\n      const input: MapPostgresColumnInput = {\n        columnName: 'id',\n        udtName: 'uuid',\n        isNullable: false,\n      };\n\n      const result = mapPostgresColumn(input);\n\n      expect(result.canonType).toBe('entity_ref');\n      expect(result.isRequired).toBe(true);\n      expect(result.maxLength).toBeUndefined();\n      expect(result.precision).toBeUndefined();\n    });\n  });\n\n  describe('CONFIDENCE_SEMANTICS', () => {\n    it('should define all confidence levels', () => {\n      expect(CONFIDENCE_SEMANTICS.EXACT).toBe(1.0);\n      expect(CONFIDENCE_SEMANTICS.SEMANTIC_EQUIV).toBe(0.95);\n      expect(CONFIDENCE_SEMANTICS.NARROWING_WITH_METADATA).toBe(0.8);\n      expect(CONFIDENCE_SEMANTICS.LOSSY_FALLBACK).toBe(0.4);\n    });\n\n    it('should have descending confidence values', () => {\n      expect(CONFIDENCE_SEMANTICS.EXACT).toBeGreaterThan(CONFIDENCE_SEMANTICS.SEMANTIC_EQUIV);\n      expect(CONFIDENCE_SEMANTICS.SEMANTIC_EQUIV).toBeGreaterThan(CONFIDENCE_SEMANTICS.NARROWING_WITH_METADATA);\n      expect(CONFIDENCE_SEMANTICS.NARROWING_WITH_METADATA).toBeGreaterThan(CONFIDENCE_SEMANTICS.LOSSY_FALLBACK);\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('should handle case-insensitive type names', () => {\n      const result1 = mapPostgresType('TEXT');\n      const result2 = mapPostgresType('text');\n      expect(result1.canonType).toBe(result2.canonType);\n    });\n\n    it('should handle types with extra whitespace', () => {\n      const result = mapPostgresType('  text  ');\n      expect(result.canonType).toBe('long_text');\n    });\n\n    it('should handle serial types as integers', () => {\n      expect(POSTGRES_TO_CANON['serial']).toBe('integer');\n      expect(POSTGRES_TO_CANON['bigserial']).toBe('integer');\n      expect(POSTGRES_TO_CANON['smallserial']).toBe('integer');\n    });\n\n    it('should map time types to short_text (no native time type)', () => {\n      expect(POSTGRES_TO_CANON['time']).toBe('short_text');\n      expect(POSTGRES_TO_CANON['time without time zone']).toBe('short_text');\n      expect(POSTGRES_TO_CANON['time with time zone']).toBe('short_text');\n    });\n\n    it('should map interval to short_text', () => {\n      expect(POSTGRES_TO_CANON['interval']).toBe('short_text');\n    });\n  });\n\n  describe('Integration scenarios', () => {\n    it('should handle a typical user table column mapping', () => {\n      const columns: MapPostgresColumnInput[] = [\n        { columnName: 'id', udtName: 'uuid', isNullable: false },\n        { columnName: 'email', udtName: 'varchar', isNullable: false, characterMaximumLength: 255 },\n        { columnName: 'name', udtName: 'text', isNullable: false },\n        { columnName: 'age', udtName: 'int4', isNullable: true },\n        { columnName: 'created_at', udtName: 'timestamptz', isNullable: false },\n        { columnName: 'is_active', udtName: 'bool', isNullable: false },\n      ];\n\n      const results = columns.map(mapPostgresColumn);\n\n      expect(results[0].canonType).toBe('entity_ref');\n      expect(results[1].canonType).toBe('short_text');\n      expect(results[2].canonType).toBe('long_text');\n      expect(results[3].canonType).toBe('integer');\n      expect(results[4].canonType).toBe('datetime');\n      expect(results[5].canonType).toBe('boolean');\n\n      // All should have confidence scores\n      results.forEach(result => {\n        expect(result.confidence).toBeDefined();\n        expect(result.confidence).toBeGreaterThan(0);\n      });\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\mappings\\__tests__\\type-compat.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\mappings\\__tests__\\type-compat.test.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Type Compatibility Matrix Tests\n * \n * Verifies all invariants from Canon Architecture §8.3\n * Tests: TC1-TC3 (diagonal exactness, symmetry, transitivity)\n */\n\nimport { describe, expect, it } from 'vitest';\nimport { DATA_TYPES, type DataType } from '../../enums/data-types';\nimport {\n  TYPE_COMPAT_MATRIX,\n  getCompatLevel,\n  isCompatible,\n  requiresTransform,\n  type CompatLevel,\n} from '../type-compat';\n\ndescribe('Type Compatibility Matrix', () => {\n  describe('TC1: All diagonals are exact', () => {\n    it('should have exact compatibility for same-type conversions', () => {\n      DATA_TYPES.forEach((type) => {\n        const level = getCompatLevel(type, type);\n        expect(level).toBe('exact');\n      });\n    });\n\n    it('should verify diagonal exactness in matrix directly', () => {\n      DATA_TYPES.forEach((type) => {\n        expect(TYPE_COMPAT_MATRIX[type][type]).toBe('exact');\n      });\n    });\n  });\n\n  describe('TC2: Matrix completeness', () => {\n    it('should have entries for all DataType pairs', () => {\n      DATA_TYPES.forEach((fromType) => {\n        DATA_TYPES.forEach((toType) => {\n          const level = TYPE_COMPAT_MATRIX[fromType][toType];\n          expect(level).toBeDefined();\n          expect(['exact', 'widening', 'narrowing', 'lossy', 'incompatible']).toContain(\n            level\n          );\n        });\n      });\n    });\n\n    it('should have no undefined entries in matrix', () => {\n      DATA_TYPES.forEach((fromType) => {\n        const row = TYPE_COMPAT_MATRIX[fromType];\n        expect(row).toBeDefined();\n\n        DATA_TYPES.forEach((toType) => {\n          expect(row[toType]).toBeDefined();\n        });\n      });\n    });\n  });\n\n  describe('TC3: Logical consistency', () => {\n    it('should mark text widening as safe (short_text → long_text)', () => {\n      expect(getCompatLevel('short_text', 'long_text')).toBe('widening');\n      expect(isCompatible('short_text', 'long_text')).toBe(true);\n    });\n\n    it('should mark text narrowing as requiring transform (long_text → short_text)', () => {\n      expect(getCompatLevel('long_text', 'short_text')).toBe('narrowing');\n      expect(requiresTransform('long_text', 'short_text')).toBe(true);\n    });\n\n    it('should mark numeric widening as safe (integer → decimal)', () => {\n      expect(getCompatLevel('integer', 'decimal')).toBe('widening');\n      expect(isCompatible('integer', 'decimal')).toBe(true);\n    });\n\n    it('should mark incompatible conversions (boolean → date)', () => {\n      expect(getCompatLevel('boolean', 'date')).toBe('incompatible');\n      expect(isCompatible('boolean', 'date')).toBe(false);\n    });\n\n    it('should mark JSON as universal receiver (widening from most types)', () => {\n      const jsonCompatibleTypes: DataType[] = [\n        'short_text',\n        'long_text',\n        'integer',\n        'decimal',\n        'boolean',\n        'date',\n        'datetime',\n      ];\n\n      jsonCompatibleTypes.forEach((type) => {\n        const level = getCompatLevel(type, 'json');\n        expect(['widening', 'exact']).toContain(level);\n      });\n    });\n  });\n\n  describe('getCompatLevel', () => {\n    it('should return exact for same types', () => {\n      expect(getCompatLevel('short_text', 'short_text')).toBe('exact');\n      expect(getCompatLevel('integer', 'integer')).toBe('exact');\n      expect(getCompatLevel('json', 'json')).toBe('exact');\n    });\n\n    it('should return incompatible for unknown type combinations', () => {\n      // Testing runtime behavior with invalid type cast\n      expect(getCompatLevel('unknown_type' as any, 'short_text')).toBe('incompatible');\n    });\n\n    it('should handle all CompatLevel values', () => {\n      // Verify that the matrix uses the expected compatibility levels\n      const levels: CompatLevel[] = ['exact', 'widening', 'narrowing', 'incompatible'];\n\n      levels.forEach((expectedLevel) => {\n        // Find at least one type pair that produces this level\n        let found = false;\n\n        for (const fromType of DATA_TYPES) {\n          for (const toType of DATA_TYPES) {\n            if (getCompatLevel(fromType, toType) === expectedLevel) {\n              found = true;\n              break;\n            }\n          }\n          if (found) break;\n        }\n\n        expect(found).toBe(true);\n      });\n    });\n  });\n\n  describe('isCompatible', () => {\n    it('should return true for exact and widening conversions', () => {\n      expect(isCompatible('short_text', 'short_text')).toBe(true); // exact\n      expect(isCompatible('short_text', 'long_text')).toBe(true); // widening\n      expect(isCompatible('integer', 'decimal')).toBe(true); // widening\n    });\n\n    it('should return false for narrowing, lossy, and incompatible', () => {\n      expect(isCompatible('long_text', 'short_text')).toBe(false); // narrowing\n      expect(isCompatible('boolean', 'date')).toBe(false); // incompatible\n    });\n  });\n\n  describe('requiresTransform', () => {\n    it('should return true for narrowing and lossy conversions', () => {\n      expect(requiresTransform('long_text', 'short_text')).toBe(true); // narrowing\n      expect(requiresTransform('decimal', 'integer')).toBe(true); // narrowing\n    });\n\n    it('should return false for exact, widening, and incompatible', () => {\n      expect(requiresTransform('short_text', 'short_text')).toBe(false); // exact\n      expect(requiresTransform('short_text', 'long_text')).toBe(false); // widening\n      expect(requiresTransform('boolean', 'date')).toBe(false); // incompatible\n    });\n  });\n\n  describe('Specific conversion patterns', () => {\n    describe('Text conversions', () => {\n      it('should allow short_text → long_text (widening)', () => {\n        expect(getCompatLevel('short_text', 'long_text')).toBe('widening');\n      });\n\n      it('should allow text → json (widening)', () => {\n        expect(getCompatLevel('short_text', 'json')).toBe('widening');\n        expect(getCompatLevel('long_text', 'json')).toBe('widening');\n      });\n\n      it('should handle text → rich_text conversion', () => {\n        // Verify the actual compatibility level (may be exact or widening)\n        const shortToRich = getCompatLevel('short_text', 'rich_text');\n        const longToRich = getCompatLevel('long_text', 'rich_text');\n        expect(['exact', 'widening']).toContain(shortToRich);\n        expect(['exact', 'widening']).toContain(longToRich);\n      });\n    });\n\n    describe('Numeric conversions', () => {\n      it('should allow integer → decimal (widening)', () => {\n        expect(getCompatLevel('integer', 'decimal')).toBe('widening');\n      });\n\n      it('should mark decimal → integer as narrowing', () => {\n        expect(getCompatLevel('decimal', 'integer')).toBe('narrowing');\n      });\n\n      it('should allow numeric → json (widening)', () => {\n        expect(getCompatLevel('integer', 'json')).toBe('widening');\n        expect(getCompatLevel('decimal', 'json')).toBe('widening');\n      });\n    });\n\n    describe('Date/Time conversions', () => {\n      it('should allow date → datetime (widening)', () => {\n        expect(getCompatLevel('date', 'datetime')).toBe('widening');\n      });\n\n      it('should mark datetime → date as narrowing', () => {\n        expect(getCompatLevel('datetime', 'date')).toBe('narrowing');\n      });\n\n      it('should allow date/datetime → text (widening)', () => {\n        expect(getCompatLevel('date', 'short_text')).toBe('widening');\n        expect(getCompatLevel('datetime', 'short_text')).toBe('widening');\n      });\n    });\n\n    describe('Enum conversions', () => {\n      it('should allow enum → text (widening)', () => {\n        expect(getCompatLevel('enum', 'short_text')).toBe('widening');\n        expect(getCompatLevel('enum', 'long_text')).toBe('widening');\n      });\n\n      it('should allow single_select → multi_select (widening)', () => {\n        expect(getCompatLevel('single_select', 'multi_select')).toBe('widening');\n      });\n\n      it('should mark multi_select → single_select as narrowing', () => {\n        expect(getCompatLevel('multi_select', 'single_select')).toBe('narrowing');\n      });\n    });\n\n    describe('Special type conversions', () => {\n      it('should allow entity_ref → text (widening)', () => {\n        expect(getCompatLevel('entity_ref', 'short_text')).toBe('widening');\n        expect(getCompatLevel('entity_ref', 'long_text')).toBe('widening');\n      });\n\n      it('should allow binary → file (widening)', () => {\n        expect(getCompatLevel('binary', 'file')).toBe('widening');\n      });\n\n      it('should mark file → binary as narrowing', () => {\n        expect(getCompatLevel('file', 'binary')).toBe('narrowing');\n      });\n\n      it('should allow relation → entity_ref (widening)', () => {\n        expect(getCompatLevel('relation', 'entity_ref')).toBe('widening');\n      });\n    });\n\n    describe('JSON as universal receiver', () => {\n      it('should accept most types as compatible with json', () => {\n        const jsonCompatible: DataType[] = [\n          'short_text',\n          'long_text',\n          'integer',\n          'decimal',\n          'money',\n          'boolean',\n          'date',\n          'datetime',\n        ];\n\n        jsonCompatible.forEach((type) => {\n          const level = getCompatLevel(type, 'json');\n          // JSON can accept these types (exact, widening, or narrowing)\n          expect(['exact', 'widening', 'narrowing']).toContain(level);\n        });\n      });\n\n      it('should allow json → specific types as narrowing', () => {\n        const jsonNarrowable: DataType[] = [\n          'short_text',\n          'long_text',\n          'integer',\n          'decimal',\n          'boolean',\n        ];\n\n        jsonNarrowable.forEach((type) => {\n          const level = getCompatLevel('json', type);\n          expect(level).toBe('narrowing');\n        });\n      });\n    });\n  });\n\n  describe('Matrix symmetry properties', () => {\n    it('should have exact compatibility for same-type conversions', () => {\n      // TC1 invariant: All diagonal entries must be exact\n      DATA_TYPES.forEach((type) => {\n        const level = getCompatLevel(type, type);\n        expect(level).toBe('exact');\n      });\n    });\n\n    it('should handle bidirectional exact conversions for equivalent types', () => {\n      // Some type pairs are semantically equivalent (e.g., money ↔ decimal, currency ↔ money)\n      // Verify these have exact bidirectional conversions\n      const equivalentPairs: Array<[DataType, DataType]> = [\n        ['money', 'decimal'],\n        ['money', 'currency'],\n        ['decimal', 'currency'],\n      ];\n\n      equivalentPairs.forEach(([typeA, typeB]) => {\n        const forward = getCompatLevel(typeA, typeB);\n        const reverse = getCompatLevel(typeB, typeA);\n\n        // Both should be exact for equivalent types\n        if (forward === 'exact') {\n          expect(reverse).toBe('exact');\n        }\n      });\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('should handle formula type (read-only, incompatible with most)', () => {\n      DATA_TYPES.forEach((type) => {\n        if (type !== 'formula') {\n          const level = getCompatLevel('formula', type);\n          expect(level).toBe('incompatible');\n        }\n      });\n    });\n\n    it('should handle money type conversions', () => {\n      expect(getCompatLevel('money', 'decimal')).toBe('exact');\n      expect(getCompatLevel('money', 'currency')).toBe('exact');\n      expect(getCompatLevel('decimal', 'money')).toBe('exact');\n    });\n\n    it('should handle email/phone/url as specialized text', () => {\n      expect(getCompatLevel('email', 'short_text')).toBe('narrowing');\n      expect(getCompatLevel('phone', 'short_text')).toBe('narrowing');\n      expect(getCompatLevel('url', 'short_text')).toBe('narrowing');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\mappings\\csv-types.ts","messages":[{"ruleId":"import/order","severity":2,"message":"`./postgres-types` import should occur before type import of `../enums/data-types`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":57,"fix":{"range":[148,262],"text":"import { CONFIDENCE_SEMANTICS } from './postgres-types';\r\nimport type { DataType } from '../enums/data-types';\r\n\r\n"}},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":125,"column":19,"nodeType":"Literal","endLine":125,"endColumn":78},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":141,"column":10,"nodeType":"Literal","endLine":141,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\r\n * CSV Type Inference\r\n *\r\n * Infers Canon DataType from sample CSV column values.\r\n * Used in data discovery and migration pipelines.\r\n */\r\n\r\nimport type { DataType } from '../enums/data-types';\r\n\r\nimport { CONFIDENCE_SEMANTICS } from './postgres-types';\r\n\r\n/**\r\n * Infer Canon DataType from a sample of CSV column values\r\n *\r\n * Strategy:\r\n * 1. Try to match all values to a specific type\r\n * 2. If 100% match → return that type with confidence 1.0\r\n * 3. If mixed → return safe fallback (short_text) with lower confidence\r\n * 4. If empty → return short_text with low confidence\r\n */\r\nexport function inferCsvColumnType(\r\n  values: string[],\r\n  opts?: { sampleSize?: number }\r\n): {\r\n  canonType: DataType;\r\n  confidence: number;\r\n  notes?: string;\r\n} {\r\n  const sampleSize = opts?.sampleSize ?? values.length;\r\n  const sample = values.slice(0, sampleSize);\r\n\r\n  if (sample.length === 0) {\r\n    return {\r\n      canonType: 'short_text',\r\n      confidence: CONFIDENCE_SEMANTICS.LOSSY_FALLBACK,\r\n      notes: 'No sample values provided; defaulted to short_text',\r\n    };\r\n  }\r\n\r\n  // Try each type in order of specificity\r\n  // Most specific first, so we catch types earliest\r\n\r\n  // ISO date (YYYY-MM-DD)\r\n  if (sample.every(isIsoDate)) {\r\n    return {\r\n      canonType: 'date',\r\n      confidence: 1.0,\r\n      notes: `All ${sample.length} samples matched ISO date format`,\r\n    };\r\n  }\r\n\r\n  // ISO datetime (YYYY-MM-DDTHH:mm:ssZ)\r\n  if (sample.every(isIsoDateTime)) {\r\n    return {\r\n      canonType: 'datetime',\r\n      confidence: 1.0,\r\n      notes: `All ${sample.length} samples matched ISO datetime format`,\r\n    };\r\n  }\r\n\r\n  // Boolean (true/false, yes/no, 1/0)\r\n  if (sample.every(isBoolean)) {\r\n    return {\r\n      canonType: 'boolean',\r\n      confidence: 0.95,\r\n      notes: `All ${sample.length} samples matched boolean values`,\r\n    };\r\n  }\r\n\r\n  // Integer\r\n  if (sample.every(isInteger)) {\r\n    return {\r\n      canonType: 'integer',\r\n      confidence: 1.0,\r\n      notes: `All ${sample.length} samples are integers`,\r\n    };\r\n  }\r\n\r\n  // Decimal number\r\n  if (sample.every(isDecimal)) {\r\n    return {\r\n      canonType: 'decimal',\r\n      confidence: 1.0,\r\n      notes: `All ${sample.length} samples are decimal numbers`,\r\n    };\r\n  }\r\n\r\n  // UUID\r\n  if (sample.every(isUuid)) {\r\n    return {\r\n      canonType: 'entity_ref',\r\n      confidence: 0.9,\r\n      notes: `All ${sample.length} samples matched UUID format`,\r\n    };\r\n  }\r\n\r\n  // Short text (< 100 chars average)\r\n  const avgLength = sample.reduce((sum, s) => sum + s.length, 0) / sample.length;\r\n  if (avgLength < 100) {\r\n    return {\r\n      canonType: 'short_text',\r\n      confidence: CONFIDENCE_SEMANTICS.NARROWING_WITH_METADATA,\r\n      notes: `Inferred short_text based on average sample length ${Math.round(avgLength)} chars`,\r\n    };\r\n  }\r\n\r\n  // Long text (>= 100 chars average)\r\n  return {\r\n    canonType: 'long_text',\r\n    confidence: CONFIDENCE_SEMANTICS.NARROWING_WITH_METADATA,\r\n    notes: `Inferred long_text based on average sample length ${Math.round(avgLength)} chars`,\r\n  };\r\n}\r\n\r\n// Helper functions for type detection\r\n\r\nfunction isIsoDate(s: string): boolean {\r\n  const pattern = /^\\d{4}-\\d{2}-\\d{2}$/;\r\n  if (!pattern.test(s)) return false;\r\n  const date = new Date(s);\r\n  return !isNaN(date.getTime());\r\n}\r\n\r\nfunction isIsoDateTime(s: string): boolean {\r\n  const pattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(Z|[+-]\\d{2}:\\d{2})?$/;\r\n  return pattern.test(s);\r\n}\r\n\r\nfunction isBoolean(s: string): boolean {\r\n  const lower = s.toLowerCase().trim();\r\n  return ['true', 'false', 'yes', 'no', '1', '0', 't', 'f'].includes(lower);\r\n}\r\n\r\nfunction isInteger(s: string): boolean {\r\n  const trimmed = s.trim();\r\n  return /^-?\\d+$/.test(trimmed);\r\n}\r\n\r\nfunction isDecimal(s: string): boolean {\r\n  const trimmed = s.trim();\r\n  return /^-?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$/.test(trimmed);\r\n}\r\n\r\nfunction isUuid(s: string): boolean {\r\n  const pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\r\n  return pattern.test(s.trim());\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\mappings\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\mappings\\postgres-types.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":205,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":205,"endColumn":62}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PostgreSQL Type Mapping\r\n *\r\n * V1 deterministic mappings from Postgres types to Canon DataTypes.\r\n * Maps instance types and generates confidence scores for migration pipelines.\r\n *\r\n * Invariants (locked - see canon.architecture.md §8.1):\r\n * M1: Full coverage of known Postgres types\r\n * M2: Strict mode throws on unknown types\r\n * M3: Confidence tracking per CONFIDENCE_SEMANTICS\r\n */\r\n\r\nimport type { DataType } from '../enums/data-types';\r\n\r\n/**\r\n * Postgres type to Canon DataType mapping (V1)\r\n * M1 invariant: Complete coverage for all known PostgreSQL types\r\n */\r\nexport const POSTGRES_TO_CANON: Record<string, DataType> = {\r\n  // Text types\r\n  text: 'long_text',\r\n  varchar: 'short_text',\r\n  'character varying': 'short_text',\r\n  char: 'short_text',\r\n  character: 'short_text',\r\n  name: 'short_text',\r\n  citext: 'long_text',\r\n\r\n  // Numeric types\r\n  int2: 'integer',\r\n  int4: 'integer',\r\n  int8: 'integer',\r\n  smallint: 'integer',\r\n  integer: 'integer',\r\n  bigint: 'integer',\r\n  float4: 'decimal',\r\n  float8: 'decimal',\r\n  real: 'decimal',\r\n  'double precision': 'decimal',\r\n  numeric: 'decimal',\r\n  money: 'decimal',\r\n  serial: 'integer',\r\n  bigserial: 'integer',\r\n  smallserial: 'integer',\r\n\r\n  // Boolean\r\n  bool: 'boolean',\r\n  boolean: 'boolean',\r\n\r\n  // Date/Time\r\n  date: 'date',\r\n  timestamp: 'datetime',\r\n  'timestamp without time zone': 'datetime',\r\n  'timestamp with time zone': 'datetime',\r\n  timestamptz: 'datetime',\r\n  time: 'short_text',\r\n  'time without time zone': 'short_text',\r\n  'time with time zone': 'short_text',\r\n  timetz: 'short_text',\r\n  interval: 'short_text',\r\n\r\n  // JSON\r\n  json: 'json',\r\n  jsonb: 'json',\r\n\r\n  // Binary\r\n  bytea: 'binary',\r\n\r\n  // UUID\r\n  uuid: 'entity_ref',\r\n\r\n  // Array\r\n  'text[]': 'multi_select',\r\n  'varchar[]': 'multi_select',\r\n  'integer[]': 'json',\r\n  'int4[]': 'json',\r\n  'jsonb[]': 'json',\r\n\r\n  // Geometric (GIS)\r\n  point: 'json',\r\n  line: 'json',\r\n  lseg: 'json',\r\n  box: 'json',\r\n  path: 'json',\r\n  polygon: 'json',\r\n  circle: 'json',\r\n\r\n  // Network\r\n  inet: 'short_text',\r\n  cidr: 'short_text',\r\n  macaddr: 'short_text',\r\n  macaddr8: 'short_text',\r\n\r\n  // Range types\r\n  int4range: 'json',\r\n  int8range: 'json',\r\n  numrange: 'json',\r\n  tsrange: 'json',\r\n  tstzrange: 'json',\r\n  daterange: 'json',\r\n\r\n  // Search\r\n  tsvector: 'long_text',\r\n  tsquery: 'short_text',\r\n\r\n  // Other\r\n  xml: 'long_text',\r\n  bit: 'short_text',\r\n  'bit varying': 'short_text',\r\n  varbit: 'short_text',\r\n  oid: 'integer',\r\n  regclass: 'short_text',\r\n  regtype: 'short_text',\r\n};\r\n\r\n/**\r\n * Input for mapping a PostgreSQL column\r\n */\r\nexport interface MapPostgresColumnInput {\r\n  columnName: string;\r\n  udtName: string; // pg type from information_schema\r\n  isNullable: boolean;\r\n  characterMaximumLength?: number;\r\n  numericPrecision?: number;\r\n  numericScale?: number;\r\n}\r\n\r\n/**\r\n * Output of mapping a PostgreSQL column\r\n */\r\nexport interface MapPostgresColumnOutput {\r\n  canonType: DataType;\r\n  isRequired: boolean;\r\n  maxLength?: number;\r\n  precision?: number;\r\n  scale?: number;\r\n  confidence?: number; // 1.0 = exact, <1.0 = lossy/narrowing\r\n  notes?: string; // explanation if lossy or narrowed\r\n}\r\n\r\n/**\r\n * Confidence semantics for type mappings\r\n * Shared with inferCsvColumnType and other mapping functions\r\n */\r\nexport const CONFIDENCE_SEMANTICS = {\r\n  EXACT: 1.0, // Lossless, semantically equivalent\r\n  SEMANTIC_EQUIV: 0.95, // Semantically equivalent, representation differs\r\n  NARROWING_WITH_METADATA: 0.8, // Narrowing or depends on external metadata\r\n  LOSSY_FALLBACK: 0.4, // Lossy fallback / informational\r\n} as const;\r\n\r\n/**\r\n * Normalize PostgreSQL type before mapping\r\n * Handles arrays (_text, text[]), domains, composite types, and user-defined types\r\n */\r\nexport function normalizePgType(pgType: string): {\r\n  baseType: string;\r\n  isArray: boolean;\r\n  isDomain: boolean;\r\n  isComposite: boolean;\r\n} {\r\n  const lower = pgType.toLowerCase().trim();\r\n\r\n  // Check for array syntax\r\n  const isArray = lower.endsWith('[]') || lower.startsWith('_');\r\n  const base = isArray ? lower.replace(/\\[\\]$/, '').replace(/^_/, '') : lower;\r\n\r\n  // Check for composite/record type (contains .)\r\n  const isComposite = base.includes('.');\r\n\r\n  // Check for domain (UDT that might reference a base type)\r\n  // In v1, we cannot resolve domains without schema info\r\n  const isDomain = !POSTGRES_TO_CANON[base] && !isComposite;\r\n\r\n  return { baseType: base, isArray, isDomain, isComposite };\r\n}\r\n\r\n/**\r\n * Map a Postgres type to Canon DataType\r\n *\r\n * @param pgType - PostgreSQL type name\r\n * @param meta - Optional metadata (characterMaximumLength, numericPrecision, numericScale)\r\n * @param opts - Options (mode: 'strict' | 'loose')\r\n *\r\n * Strict mode: Unknown types throw\r\n * Loose mode: Unknown types return 'short_text' with warning\r\n *\r\n * M2 invariant: Strict mode throws on unknown types; never silent fallback\r\n * M3 invariant: Returns confidence per CONFIDENCE_SEMANTICS\r\n */\r\nexport function mapPostgresType(\r\n  pgType: string,\r\n  meta?: { maxLength?: number; precision?: number; scale?: number },\r\n  opts?: { mode?: 'strict' | 'loose' }\r\n): {\r\n  canonType: DataType;\r\n  confidence: number;\r\n  notes?: string;\r\n} {\r\n  const mode = opts?.mode ?? 'strict';\r\n  const normalized = normalizePgType(pgType);\r\n\r\n  // Known type\r\n  if (POSTGRES_TO_CANON[normalized.baseType]) {\r\n    const canonType = POSTGRES_TO_CANON[normalized.baseType]!;\r\n\r\n    // M3 invariant: Determine confidence\r\n    // timestamp → datetime preserves semantics\r\n    if (pgType === 'timestamp' || pgType === 'timestamptz') {\r\n      return {\r\n        canonType,\r\n        confidence: CONFIDENCE_SEMANTICS.SEMANTIC_EQUIV,\r\n        notes: 'Postgres timestamp types preserve full precision; timezone handling differs slightly',\r\n      };\r\n    }\r\n\r\n    // varchar(n) narrowing on large n\r\n    if (\r\n      pgType.startsWith('varchar') &&\r\n      meta?.maxLength &&\r\n      meta.maxLength > 255\r\n    ) {\r\n      return {\r\n        canonType,\r\n        confidence: CONFIDENCE_SEMANTICS.NARROWING_WITH_METADATA,\r\n        notes: `varchar(${meta.maxLength}) mapped to long_text`,\r\n      };\r\n    }\r\n\r\n    // uuid → entity_ref may require external validation\r\n    if (pgType === 'uuid') {\r\n      return {\r\n        canonType,\r\n        confidence: CONFIDENCE_SEMANTICS.NARROWING_WITH_METADATA,\r\n        notes: 'UUID mapped to entity_ref (reference semantics depend on schema context)',\r\n      };\r\n    }\r\n\r\n    // Default: exact match\r\n    return {\r\n      canonType,\r\n      confidence: CONFIDENCE_SEMANTICS.EXACT,\r\n    };\r\n  }\r\n\r\n  // Domain type (requires schema resolution)\r\n  if (normalized.isDomain) {\r\n    if (mode === 'strict') {\r\n      throw new Error(\r\n        `Unknown PostgreSQL type: '${pgType}'. Domain types require schema resolution. Use loose mode to fallback.`\r\n      );\r\n    }\r\n    return {\r\n      canonType: 'short_text',\r\n      confidence: CONFIDENCE_SEMANTICS.LOSSY_FALLBACK,\r\n      notes: `Unknown domain type '${pgType}' (schema resolution required); fell back to short_text`,\r\n    };\r\n  }\r\n\r\n  // Composite/record type\r\n  if (normalized.isComposite) {\r\n    if (mode === 'strict') {\r\n      throw new Error(\r\n        `Composite types not supported in strict mode: '${pgType}'. Use loose mode to map to json.`\r\n      );\r\n    }\r\n    return {\r\n      canonType: 'json',\r\n      confidence: CONFIDENCE_SEMANTICS.LOSSY_FALLBACK,\r\n      notes: `Composite type '${pgType}' mapped to json (loses structure)`,\r\n    };\r\n  }\r\n\r\n  // Unknown type\r\n  if (mode === 'strict') {\r\n    throw new Error(\r\n      `Unknown PostgreSQL type: '${pgType}'. This type is not in the v1 mapping table.`\r\n    );\r\n  }\r\n\r\n  return {\r\n    canonType: 'short_text',\r\n    confidence: CONFIDENCE_SEMANTICS.LOSSY_FALLBACK,\r\n    notes: `Unknown type '${pgType}'; fell back to short_text`,\r\n  };\r\n}\r\n\r\n/**\r\n * Map a PostgreSQL column to Canon column representation\r\n */\r\nexport function mapPostgresColumn(input: MapPostgresColumnInput): MapPostgresColumnOutput {\r\n  const mapped = mapPostgresType(input.udtName, {\r\n    ...(input.characterMaximumLength !== undefined && { maxLength: input.characterMaximumLength }),\r\n    ...(input.numericPrecision !== undefined && { precision: input.numericPrecision }),\r\n    ...(input.numericScale !== undefined && { scale: input.numericScale }),\r\n  });\r\n\r\n  return {\r\n    canonType: mapped.canonType,\r\n    isRequired: !input.isNullable,\r\n    ...(input.characterMaximumLength !== undefined && { maxLength: input.characterMaximumLength }),\r\n    ...(input.numericPrecision !== undefined && { precision: input.numericPrecision }),\r\n    ...(input.numericScale !== undefined && { scale: input.numericScale }),\r\n    confidence: mapped.confidence,\r\n    ...(mapped.notes && { notes: mapped.notes }),\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\mappings\\type-compat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\registries\\capability-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\registries\\entity-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\registries\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\action.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\audit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\capability.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\data-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\envelope.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\json-value.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\lite-meta.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\mutation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\schemas\\receipt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\action-spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\action.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\actor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\audit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\capability.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\entity-contract.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\envelope.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\lifecycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\mutation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\policy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\types\\receipt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI-BOS\\AFENDA-NEXUS\\packages\\canon\\src\\validators\\custom-field-value.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]