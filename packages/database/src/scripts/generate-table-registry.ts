/* eslint-disable no-console, no-restricted-syntax */
/**
 * Table registry generator — Gate 7
 *
 * Generates _registry.ts from __TABLE_NAMES__ manifest + config files.
 * Run: pnpm db:barrel (invoked after schema barrel)
 *
 * Validations:
 * - Every TABLE_KIND_OVERRIDES key exists in discovered tables
 * - Every REVOKE_UPDATE_DELETE_TABLES name exists in discovered tables
 * - Every REGISTRY_EXEMPT name does NOT exist in discovered tables
 * - No duplicate table names in manifest
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';

import { REVOKE_UPDATE_DELETE_TABLES } from '../../revoke.config.js';
import { REGISTRY_EXEMPT, TABLE_KIND_OVERRIDES } from '../../table-registry.config.js';
import { __TABLE_NAMES__ } from '../schema/__schema-manifest.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const REGISTRY_FILE = path.resolve(__dirname, '..', 'schema', '_registry.ts');

type TableKind = 'truth' | 'control' | 'projection' | 'evidence' | 'link' | 'system';

function validateAndBuild(): Map<string, TableKind> {
  const tableNames = [...__TABLE_NAMES__];
  const tableSet = new Set<string>(tableNames);

  // No duplicates
  if (tableSet.size !== tableNames.length) {
    const seen = new Set<string>();
    const dupes = tableNames.filter((n) => (seen.has(n) ? true : (seen.add(n), false)));
    throw new Error(`[generate-table-registry] Duplicate table names in manifest: ${dupes.join(', ')}`);
  }

  // Override keys must exist
  for (const key of Object.keys(TABLE_KIND_OVERRIDES)) {
    if (!tableSet.has(key)) {
      throw new Error(`[generate-table-registry] Override refers to unknown table: ${key}`);
    }
  }

  // REGISTRY_EXEMPT must NOT exist in discovered tables
  for (const name of REGISTRY_EXEMPT) {
    if (tableSet.has(name)) {
      throw new Error(
        `[generate-table-registry] REGISTRY_EXEMPT "${name}" exists in schema — add schema or remove from exempt`,
      );
    }
  }

  // REVOKE names must exist
  for (const name of REVOKE_UPDATE_DELETE_TABLES) {
    if (!tableSet.has(name)) {
      throw new Error(`[generate-table-registry] REVOKE_UPDATE_DELETE_TABLES refers to unknown table: ${name}`);
    }
  }

  const registry = new Map<string, TableKind>();
  for (const name of tableNames) {
    const kind = name in TABLE_KIND_OVERRIDES ? TABLE_KIND_OVERRIDES[name as keyof typeof TABLE_KIND_OVERRIDES] : 'truth';
    registry.set(name, kind);
  }
  return registry;
}

function generateRegistryFile(registry: Map<string, TableKind>): string {
  const sortedEntries = [...registry.entries()].sort((a, b) => a[0].localeCompare(b[0]));
  const tableRegistryLines = sortedEntries.map(([name, kind]) => `  ${name}: '${kind}',`);

  const exemptList = REGISTRY_EXEMPT.map((n) => `  '${n}',`).join('\n');
  const revokeList = REVOKE_UPDATE_DELETE_TABLES.map((n) => `  '${n}',`).join('\n');

  return `/**
 * Table taxonomy registry — SCH-03a/03b. GENERATED by pnpm db:barrel
 * Do not edit manually. Policy lives in table-registry.config.ts and revoke.config.ts
 *
 * table_kind: truth | control | projection | evidence | link | system
 */

export type TableKind = 'truth' | 'control' | 'projection' | 'evidence' | 'link' | 'system';

export const TABLE_REGISTRY = {
${tableRegistryLines.join('\n')}
} as const satisfies Record<string, TableKind>;

/** Tables exempt from registry requirement (EX-SCH-*). */
export const REGISTRY_EXEMPT = new Set<string>([
${exemptList}
]);

/**
 * GAP-DB-005: RLS tables derived from TABLE_REGISTRY (tenant-scoped).
 * Excludes system (EX-RLS-001: users, r2_files use authUid).
 */
export const RLS_TABLES: readonly string[] = Object.entries(TABLE_REGISTRY)
  .filter(([, kind]) => kind !== 'system')
  .map(([name]) => name)
  .sort();

/**
 * Tables where UPDATE/DELETE is revoked (append-only or projection-only).
 * GAP-DB-003, Gate 6.
 */
export const REVOKE_UPDATE_DELETE_TABLES: readonly string[] = [
${revokeList}
];
`;
}

// ── Main ─────────────────────────────────────────────────
try {
  const registry = validateAndBuild();
  const content = generateRegistryFile(registry);
  const existing = fs.existsSync(REGISTRY_FILE) ? fs.readFileSync(REGISTRY_FILE, 'utf-8') : '';

  if (content !== existing) {
    fs.writeFileSync(REGISTRY_FILE, content, 'utf-8');
    console.log(`✅ Generated ${path.relative(process.cwd(), REGISTRY_FILE)} (${registry.size} tables)`);
  } else {
    console.log('✅ Table registry unchanged');
  }
} catch (err) {
  console.error(err instanceof Error ? err.message : err);
  process.exit(1);
}
