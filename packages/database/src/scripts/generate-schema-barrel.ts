/* eslint-disable no-console, no-restricted-syntax */
/**
 * Schema barrel generator — Drizzle utilization (Phase 1)
 *
 * Auto-generates packages/database/src/schema/index.ts from schema/*.ts files.
 * Replaces 370+ lines of manual exports with a single source of truth.
 *
 * Run: pnpm db:barrel
 * Run from packages/database directory.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SCHEMA_DIR = path.resolve(__dirname, '..', 'schema');
const INDEX_FILE = path.join(SCHEMA_DIR, 'index.ts');
const MANIFEST_FILE = path.join(SCHEMA_DIR, '__schema-manifest.ts');

const SKIP_FILES = new Set(['index.ts', '__schema-manifest.ts']);
const SKIP_FOR_MANIFEST = new Set(['_registry.ts', 'index.ts', 'relations.ts', 'spine-relations.ts']);

/** Matches pgTable('table_name', ...) or pgTable("table_name", ...) */
const PG_TABLE_RE = /pgTable\s*\(\s*['"]([^'"]+)['"]/g;

function getSchemaFiles(): string[] {
  const files = fs.readdirSync(SCHEMA_DIR);
  return files
    .filter((f) => f.endsWith('.ts') && !SKIP_FILES.has(f))
    .sort((a, b) => a.localeCompare(b));
}

function discoverTableNames(): string[] {
  const files = fs.readdirSync(SCHEMA_DIR);
  const names = new Set<string>();
  for (const file of files) {
    if (!file.endsWith('.ts') || SKIP_FOR_MANIFEST.has(file)) continue;
    const filePath = path.join(SCHEMA_DIR, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    let m: RegExpExecArray | null;
    PG_TABLE_RE.lastIndex = 0;
    while ((m = PG_TABLE_RE.exec(content)) !== null) {
      names.add(m[1]);
    }
  }
  return [...names].sort();
}

function generateManifest(): string {
  const tableNames = discoverTableNames();
  const lines = [
    '/**',
    ' * Schema manifest — auto-generated by pnpm db:barrel',
    ' * Do not edit manually. Used by generate-table-registry.ts',
    ' */',
    '',
    `export const __TABLE_NAMES__ = ${JSON.stringify(tableNames)} as const;`,
    '',
  ];
  return lines.join('\n');
}

function generateBarrel(): string {
  const files = getSchemaFiles();
  const lines: string[] = [
    '/**',
    ' * Schema barrel — auto-generated by pnpm db:barrel',
    ' * Do not edit manually. Run: pnpm db:barrel',
    ' */',
    '',
  ];

  for (const file of files) {
    const base = file.replace(/\.ts$/, '');
    lines.push(`export * from './${base}';`);
  }

  // Entity-gen marker: entity-new.ts inserts new schema exports here
  lines.push('// @entity-gen:schema-barrel');
  lines.push('');
  return lines.join('\n');
}

// ── Main ─────────────────────────────────────────────────
const barrelContent = generateBarrel();
const barrelExisting = fs.existsSync(INDEX_FILE) ? fs.readFileSync(INDEX_FILE, 'utf-8') : '';
if (barrelContent !== barrelExisting) {
  fs.writeFileSync(INDEX_FILE, barrelContent, 'utf-8');
  console.log(`✅ Generated ${INDEX_FILE} (${getSchemaFiles().length} schema files)`);
} else {
  console.log('✅ Schema barrel unchanged');
}

const manifestContent = generateManifest();
const manifestExisting = fs.existsSync(MANIFEST_FILE) ? fs.readFileSync(MANIFEST_FILE, 'utf-8') : '';
if (manifestContent !== manifestExisting) {
  fs.writeFileSync(MANIFEST_FILE, manifestContent, 'utf-8');
  console.log(`✅ Generated ${MANIFEST_FILE} (${discoverTableNames().length} tables)`);
} else {
  console.log('✅ Schema manifest unchanged');
}
