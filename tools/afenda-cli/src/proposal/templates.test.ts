import { describe, it, expect } from 'vitest';
import { renderProposalMd } from './templates';
import type { ProposalAnalysis } from './analyzer';
import type { ProjectAnalysis } from '../project/analyzer';
import type { ValidationResult } from '../project/validator';

function mkProjectAnalysis(overrides?: Partial<ProjectAnalysis>): ProjectAnalysis {
  return {
    repoRoot: '/repo',
    generatedAt: '2025-01-01',
    workspace: {
      packages: ['packages/a', 'packages/b'],
      corePackages: ['packages/canon', 'packages/database'],
      domainPackages: ['business-domain/finance/accounting'],
      tools: ['tools/cli'],
      apps: ['apps/web'],
    },
    manifest: {
      tableCount: 100,
      totalFiles: 500,
      totalLoc: 50000,
      totalTestFiles: 80,
      totalTestLoc: 4000,
      packageCount: 20,
    },
    docsExist: { architecture: true, governance: true, businessDomain: true },
    ...overrides,
  };
}

function mkProposalAnalysis(overrides?: Partial<ProposalAnalysis>): ProposalAnalysis {
  return {
    repoRoot: '/repo',
    generatedAt: '2025-01-15',
    projectAnalysis: mkProjectAnalysis(),
    validations: [],
    failingValidations: [],
    hasOrphanedCapabilities: false,
    advisoryPackageExists: true,
    catalogCompliant: null,
    metaCheckPassed: null,
    advisoryRefCount: 0,
    ...overrides,
  };
}

describe('renderProposalMd', () => {
  it('includes expected heading', () => {
    const out = renderProposalMd(mkProposalAnalysis());
    expect(out).toContain('# Proposal: Rolling Architecture & CLI Improvements');
  });

  it('includes autogen marker', () => {
    const out = renderProposalMd(mkProposalAnalysis());
    expect(out).toContain('<!-- Generated by afenda proposal gen');
  });

  it('includes current state with domain/core counts', () => {
    const analysis = mkProposalAnalysis({
      projectAnalysis: mkProjectAnalysis({
        workspace: {
          packages: [],
          corePackages: ['packages/canon'],
          domainPackages: ['business-domain/finance/accounting', 'business-domain/tax'],
          tools: [],
          apps: [],
        },
      }),
    });
    const out = renderProposalMd(analysis);
    expect(out).toContain('**Core packages:** 1');
    expect(out).toContain('**Domain packages:** 2');
  });

  it('shows validation failures in table when present', () => {
    const validations: ValidationResult[] = [
      { command: 'housekeeping', status: 'fail', notes: 'Catalog mismatch', exitCode: 1 },
      { command: 'meta:check', status: 'pass', notes: 'Ok', exitCode: 0 },
    ];
    const analysis = mkProposalAnalysis({
      validations,
      failingValidations: validations.filter((v) => v.status === 'fail'),
    });
    const out = renderProposalMd(analysis);
    expect(out).toContain('| Command | Status | Notes |');
    expect(out).toContain('housekeeping');
    expect(out).toContain('Catalog mismatch');
  });

  it('shows "All validations passed" when no failures', () => {
    const out = renderProposalMd(mkProposalAnalysis());
    expect(out).toContain('All validations passed. No immediate action required.');
  });

  it('includes orphaned recommendation only when meta check fails', () => {
    const withMetaFail = mkProposalAnalysis({ hasOrphanedCapabilities: true, metaCheckPassed: false });
    const outFail = renderProposalMd(withMetaFail);
    expect(outFail).toContain('afenda meta fix');

    const withMetaPass = mkProposalAnalysis({ hasOrphanedCapabilities: true, metaCheckPassed: true });
    const outPass = renderProposalMd(withMetaPass);
    expect(outPass).not.toContain('afenda meta fix');
    expect(outPass).toContain('accepted');
  });

  it('includes advisory package status', () => {
    const withAdvisory = renderProposalMd(mkProposalAnalysis({ advisoryPackageExists: true }));
    expect(withAdvisory).toContain('Advisory package:** Present');

    const withoutAdvisory = renderProposalMd(mkProposalAnalysis({ advisoryPackageExists: false }));
    expect(withoutAdvisory).toContain('Removed (tables retained)');
  });

  it('includes bundle integration section', () => {
    const out = renderProposalMd(mkProposalAnalysis());
    expect(out).toContain('## 5. Bundle Integration');
    expect(out).toContain('--skip-project');
    expect(out).toContain('--skip-proposal');
  });

  it('escapes pipe chars in validation notes', () => {
    const validations: ValidationResult[] = [
      { command: 'housekeeping', status: 'fail', notes: 'Bad | value', exitCode: 1 },
    ];
    const analysis = mkProposalAnalysis({
      validations,
      failingValidations: validations,
    });
    const out = renderProposalMd(analysis);
    expect(out).toContain('Bad \\| value');
  });
});
