/**
 * AI context emitter — generates .agent/context/capability-map.md
 * A structured markdown document that AI agents can consume to understand
 * the system's capability surface, RBAC model, and entity relationships.
 */

import { writeFileSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';

import {
  CAPABILITY_CATALOG,
  CAPABILITY_KEYS,
  VIS_POLICY,
  RBAC_TIERS,
  inferKindFromVerb,
  parseCapabilityKey,
} from 'afena-canon';

import type { CapabilityKind } from 'afena-canon';

/**
 * Generate the AI context markdown document.
 */
export function generateAiContext(): string {
  const lines: string[] = [];

  lines.push('# Capability Map — AI Agent Context');
  lines.push('');
  lines.push(`> Auto-generated by \`afena meta gen\`. Do not edit manually.`);
  lines.push(`> VIS_POLICY.phase = ${VIS_POLICY.phase}`);
  lines.push(`> Total capabilities: ${CAPABILITY_KEYS.length}`);
  lines.push('');

  // Group by kind
  const byKind = new Map<CapabilityKind, typeof entries>();
  const entries = CAPABILITY_KEYS.map((key) => {
    const d = CAPABILITY_CATALOG[key];
    const parsed = parseCapabilityKey(key);
    const kind = d.kind ?? inferKindFromVerb(parsed.verb);
    return { key, kind, descriptor: d, parsed };
  });

  for (const entry of entries) {
    const group = byKind.get(entry.kind) ?? [];
    group.push(entry);
    byKind.set(entry.kind, group);
  }

  // RBAC tier summary
  lines.push('## RBAC Tier Summary');
  lines.push('');
  lines.push('| Tier | Capabilities |');
  lines.push('|------|-------------|');
  for (const tier of RBAC_TIERS) {
    const count = entries.filter((e) => e.descriptor.rbacTier === tier).length;
    if (count > 0) {
      const keys = entries
        .filter((e) => e.descriptor.rbacTier === tier)
        .map((e) => `\`${e.key}\``)
        .join(', ');
      lines.push(`| ${tier} | ${keys} |`);
    }
  }
  lines.push('');

  // Capabilities by kind
  lines.push('## Capabilities by Kind');
  lines.push('');

  for (const [kind, group] of byKind) {
    lines.push(`### ${kind.charAt(0).toUpperCase() + kind.slice(1)} (${group.length})`);
    lines.push('');
    lines.push('| Key | Intent | Tier | Scope | Status | Entities |');
    lines.push('|-----|--------|------|-------|--------|----------|');
    for (const e of group) {
      const d = e.descriptor;
      lines.push(
        `| \`${d.key}\` | ${d.intent} | ${d.rbacTier ?? '—'} | ${d.rbacScope ?? '—'} | ${d.status} | ${(d.entities ?? []).join(', ') || '—'} |`,
      );
    }
    lines.push('');
  }

  // Entity → capability mapping
  lines.push('## Entity → Capability Mapping');
  lines.push('');
  const byEntity = new Map<string, string[]>();
  for (const e of entries) {
    for (const entity of e.descriptor.entities ?? []) {
      const group = byEntity.get(entity) ?? [];
      group.push(e.key);
      byEntity.set(entity, group);
    }
  }
  for (const [entity, keys] of [...byEntity].sort((a, b) => a[0].localeCompare(b[0]))) {
    lines.push(`- **${entity}**: ${keys.map((k) => `\`${k}\``).join(', ')}`);
  }
  lines.push('');

  // Headless capabilities
  const headless = entries.filter((e) => e.descriptor.headlessOnly);
  if (headless.length > 0) {
    lines.push('## Headless-Only Capabilities');
    lines.push('');
    lines.push('These capabilities have no UI surface — they are engine-internal or API-only:');
    lines.push('');
    for (const e of headless) {
      lines.push(`- \`${e.key}\` — ${e.descriptor.intent}`);
    }
    lines.push('');
  }

  // Risk-bearing capabilities
  const risky = entries.filter((e) => (e.descriptor.risks ?? []).length > 0);
  if (risky.length > 0) {
    lines.push('## Risk-Bearing Capabilities');
    lines.push('');
    for (const e of risky) {
      lines.push(`- \`${e.key}\` — risks: ${(e.descriptor.risks ?? []).join(', ')}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Write the AI context to .agent/context/capability-map.md
 */
export function writeAiContext(repoRoot: string, content: string): void {
  const outPath = join(repoRoot, '.agent', 'context', 'capability-map.md');
  mkdirSync(dirname(outPath), { recursive: true });
  writeFileSync(outPath, content, 'utf-8');
}
